<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shape Map Editor</title>

    <!-- Modular JavaScript imports -->
    <script src="js/managers/SelectionManager.js"></script>
    <script src="js/managers/ToolManager.js"></script>
    <script src="js/managers/TurretManager.js"></script>
    <script src="js/managers/FloorManager.js"></script>
    
    <!-- Wait for all scripts to load before initializing -->
    <script>
        // Ensure all manager classes are available before proceeding
        window.addEventListener('DOMContentLoaded', function() {
            // Small delay to ensure all scripts are fully loaded
            setTimeout(function() {
                if (typeof SelectionManager === 'undefined') {
                    console.error('SelectionManager not loaded, creating fallback');
                    window.SelectionManager = class SelectionManager {
                        constructor() {
                            this.selectedItem = null;
                            this.selectedType = null;
                            this.initialized = true;
                        }
                        selectItem(item, type) {
                            this.clearSelection();
                            this.selectedItem = item;
                            this.selectedType = type;
                            if (item) item.selected = true;
                        }
                        clearSelection() {
                            if (this.selectedItem) this.selectedItem.selected = false;
                            this.selectedItem = null;
                            this.selectedType = null;
                        }
                        getSelected() {
                            return { item: this.selectedItem, type: this.selectedType };
                        }
                        isSelected(item) {
                            return this.selectedItem === item;
                        }
                        hasSelection() {
                            return this.selectedItem !== null;
                        }
                    };
                }
                
                if (typeof ToolManager === 'undefined') {
                    console.error('ToolManager not loaded, creating fallback');
                    window.ToolManager = class ToolManager {
                        constructor() {
                            this.currentTool = null;
                            this.initialized = true;
                        }
                    };
                }
            }, 100);
        });
    </script>
    
    <script>
        // Fallback empty classes if modules don't exist
        window.Turret = window.Turret || class Turret {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.rotation = 0;
                this.selected = false;
                this.range = 30 * 40; // 30 meters
            }

            contains(x, y) {
                const dist = Math.sqrt((x - this.x) ** 2 + (y - this.y) ** 2);
                return dist <= 25;
            }

            draw(ctx, zoom = 1) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                const radius = 25;
                ctx.fillStyle = this.selected ? '#e74c3c' : '#A57070';
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 3 / zoom;

                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Draw turret barrel
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3 / zoom;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -15);
                ctx.stroke();

                ctx.restore();
            }
        };

        window.TurretManager = window.TurretManager || class TurretManager {
            constructor() {
                this.powerContainers = [];
                this.selectedContainer = null;
                this.containerError = null;
                this.initialized = false; // Added missing property
            }

            getNextTurretNumber() {
                return Math.max(0, ...document.querySelectorAll('canvas').length) + 1;
            }

            placeTurret(x, y, gameState, callbacks) {
                const newTurret = new Turret(x, y);
                newTurret.number = this.getNextTurretNumber();
                return newTurret;
            }

            placeTurretOnFloor(x, y, floorNumber, floorData, gameState, callbacks) {
                const newTurret = new Turret(x, y);
                newTurret.number = this.getNextTurretNumber(); // Reusing getNextTurretNumber
                newTurret.floorNumber = floorNumber;
                floorData[floorNumber].turrets.push(newTurret);
                return newTurret;
            }

            addPowerContainer(name) {
                if (!name) {
                    this.containerError = "Container name cannot be empty.";
                    return false;
                }
                if (name.length > 17) {
                    this.containerError = "Container name too long (max 17 characters).";
                    return false;
                }
                if (this.powerContainers.some(c => c.name === name)) {
                    this.containerError = "Container name already exists.";
                    return false;
                }

                this.powerContainers.push({
                    id: Date.now(),
                    name: name,
                    enabled: true,
                    connectedTurrets: []
                });
                return true;
            }

            deletePowerContainer(containerId) {
                this.powerContainers = this.powerContainers.filter(c => c.id !== containerId);
            }

            connectTurretToContainer(containerId, turretNumber) {
                const container = this.powerContainers.find(c => c.id === containerId);
                if (container && !container.connectedTurrets.includes(turretNumber)) {
                    container.connectedTurrets.push(turretNumber);
                    container.connectedTurrets.sort((a, b) => a - b); // Keep sorted
                }
            }

            disconnectTurretFromContainer(containerId, turretNumber) {
                const container = this.powerContainers.find(c => c.id === containerId);
                if (container) {
                    container.connectedTurrets = container.connectedTurrets.filter(num => num !== turretNumber);
                }
            }

            getTurretStatus(turret, gameState, callbacks) {
                const isPowered = isTurretPowered(turret.number);
                const isOverLimit = isTurretOverLimit(turret.number);
                const isConnectedUnpowered = isTurretConnectedUnpowered(turret.number);

                let status = '';
                if (isOverLimit) {
                    status = 'OVERLOAD';
                } else if (isConnectedUnpowered) {
                    status = 'UNPOWERED';
                } else if (!isPowered) {
                    status = 'OFFLINE';
                } else {
                    status = 'ONLINE';
                }

                return status;
            }

            // Initialize global turret counter
            initializeGlobalTurretCounter(gameState, floorData) {
                let globalCounter = 0;
                const allTurrets = [];

                // Collect turrets from main floor
                if (gameState && gameState.turrets) {
                    gameState.turrets.forEach(turret => {
                        turret.number = ++globalCounter;
                        allTurrets.push(turret);
                    });
                }

                // Collect turrets from additional floors
                if (floorData) {
                    Object.keys(floorData).forEach(floorKey => {
                        if (floorKey !== '1' && floorData[floorKey] && floorData[floorKey].turrets) {
                            floorData[floorKey].turrets.forEach(turret => {
                                turret.number = ++globalCounter;
                                turret.floorNumber = parseInt(floorKey);
                                allTurrets.push(turret);
                            });
                        }
                    });
                }

                // Re-assign numbers to turrets in arrays based on global count
                // This ensures consistent numbering across all floors after loading or changes
                let currentGlobalNumber = 1;
                if (gameState && gameState.turrets) {
                    gameState.turrets.forEach(turret => {
                        turret.number = currentGlobalNumber++;
                    });
                }

                if (floorData) {
                    Object.keys(floorData).forEach(floorKey => {
                        if (floorKey !== '1' && floorData[floorKey] && floorData[floorKey].turrets) {
                            floorData[floorKey].turrets.forEach(turret => {
                                turret.number = currentGlobalNumber++;
                                turret.floorNumber = parseInt(floorKey);
                            });
                        }
                    });
                }
            }

            // Update all turret numbers globally
            updateAllTurretNumbers(gameState, floorData) {
                let globalCounter = 1;
                const allTurrets = [];

                // Collect turrets from main floor
                if (gameState && gameState.turrets) {
                    allTurrets.push(...gameState.turrets);
                }

                // Collect turrets from additional floors
                if (floorData) {
                    Object.keys(floorData).forEach(floorKey => {
                        if (floorKey !== '1' && floorData[floorKey] && floorData[floorKey].turrets) {
                            floorData[floorKey].turrets.forEach(turret => {
                                turret.floorNumber = parseInt(floorKey); // Ensure floorNumber is set
                            });
                            allTurrets.push(...floorData[floorKey].turrets);
                        }
                    });
                }

                // Sort turrets to ensure consistent numbering
                allTurrets.sort((a, b) => {
                    // Sort by floor first, then by y-coordinate, then by x-coordinate
                    if (a.floorNumber !== b.floorNumber) {
                        return (a.floorNumber || 1) - (b.floorNumber || 1);
                    }
                    if (a.y !== b.y) {
                        return a.y - b.y;
                    }
                    return a.x - b.x;
                });

                // Re-assign numbers
                allTurrets.forEach(turret => {
                    turret.number = globalCounter++;
                });
            }

            // Update turret numbers for a specific floor
            updateTurretNumbers(floorNumber) {
                // This functionality is now handled globally by updateAllTurretNumbers
                // Call it with current game state and floor data
                updateAllTurretNumbers({ turrets }, floorManager.floorData);
            }
        };

        window.FloorManager = window.FloorManager || class FloorManager {
            constructor() {
                this.floorData = {
                    1: { shapes: [], turrets: [], walls: [], windows: [], reinforcedWalls: [], garageDoors: [], securityGates: [] },
                    2: { shapes: [], turrets: [], walls: [], windows: [], reinforcedWalls: [], garageDoors: [], securityGates: [] },
                    3: { shapes: [], turrets: [], walls: [], windows: [], reinforcedWalls: [], garageDoors: [], securityGates: [] },
                    4: { shapes: [], turrets: [], walls: [], windows: [], reinforcedWalls: [], garageDoors: [], securityGates: [] },
                    5: { shapes: [], turrets: [], walls: [], windows: [], reinforcedWalls: [], garageDoors: [], securityGates: [] }
                };
                this.currentActiveFloor = 1;
                this.currentFloors = 5; // Default to 5 floors
                this.floorCanvasStates = {}; // Stores pan, zoom, initialized status for each canvas
            }

            initializeFloorSystem(elements, callbacks) {
                // Initialize canvas states and add event listeners
                const canvases = [
                    { id: 'mapCanvas', floorNum: 1, isMain: true },
                    { id: 'floor2Canvas', floorNum: 2 },
                    { id: 'floor3Canvas', floorNum: 3 },
                    { id: 'floor4Canvas', floorNum: 4 },
                    { id: 'floor5Canvas', floorNum: 5 }
                ];

                canvases.forEach(({ id, floorNum, isMain }) => {
                    const canvas = elements[id];
                    if (!canvas) return;

                    // Store initial state for each canvas
                    this.floorCanvasStates[id] = {
                        panX: 0,
                        panY: 0,
                        zoom: 1.0, // Default zoom for additional floors
                        initialized: false
                    };

                    // If it's the main canvas, set default pan/zoom
                    if (isMain) {
                        this.floorCanvasStates[id].panX = panX; // Use global panX/panY
                        this.floorCanvasStates[id].panY = panY;
                        this.floorCanvasStates[id].zoom = zoom;
                    }

                    // Initialize canvas content and event listeners
                    if (callbacks.initializeFloorCanvas) {
                        callbacks.initializeFloorCanvas(id, floorNum);
                    }
                });

                // Set initial floor display based on default currentFloors
                updateFloorDisplay(this.currentFloors);
            }

            redrawFloorCanvasContent(canvasId, floorNumber) {
                const canvas = document.getElementById(canvasId);
                if (!canvas) {
                    console.log(`Canvas ${canvasId} not found for redraw.`);
                    return;
                }
                const ctx = canvas.getContext('2d');
                const state = this.floorCanvasStates[canvasId];

                if (!state || !state.initialized) {
                    console.log(`Canvas ${canvasId} not initialized.`);
                    return;
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ctx.save();
                ctx.translate(state.panX, state.panY);
                ctx.scale(state.zoom, state.zoom);

                // Draw grid background with proper zoom scaling
                drawFloorGrid(ctx, canvasId);

                // Draw floor content
                drawFloorContent(ctx, floorNumber, state.zoom);

                // Draw ghost previews if canvas is being hovered
                drawFloorGhosts(ctx, canvasId, state.zoom);

                // Draw center dot for alignment verification (red dot at canvas center)
                ctx.save();
                ctx.fillStyle = '#ff0000';
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                // Center of 350x349 canvas
                ctx.arc(175, 174.5, 3 / state.zoom, 0, Math.PI * 2); 
                ctx.fill();
                ctx.restore();

                ctx.restore();
            }

            handleFloorCanvasZoom(e, canvas, canvasId, floorNumber) {
                e.preventDefault();
                const state = this.floorCanvasStates[canvasId];

                const mouseX = e.clientX - canvas.getBoundingClientRect().left;
                const mouseY = e.clientY - canvas.getBoundingClientRect().top;

                const worldX = (mouseX - state.panX) / state.zoom;
                const worldY = (mouseY - state.panY) / state.zoom;

                const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
                state.zoom = Math.max(0.2, Math.min(5, state.zoom * zoomDelta));

                state.panX = mouseX - worldX * state.zoom;
                state.panY = mouseY - worldY * state.zoom;

                this.redrawFloorCanvasContent(canvasId, floorNumber);
            }

            handleFloorCanvasMouseMove(e, canvas, canvasId, floorNumber) {
                const state = this.floorCanvasStates[canvasId];
                if (state.isPanningFloor) {
                    const mouseX = e.clientX - canvas.getBoundingClientRect().left;
                    const mouseY = e.clientY - canvas.getBoundingClientRect().top;
                    state.panX += mouseX - state.lastFloorMouseX;
                    state.panY += mouseY - state.lastFloorMouseY;
                    state.lastFloorMouseX = mouseX;
                    state.lastFloorMouseY = mouseY;
                    this.redrawFloorCanvasContent(canvasId, floorNumber);
                }
            }

            handleFloorCanvasClick(e, canvasId, floorNumber) {
                const canvas = document.getElementById(canvasId);
                const rect = canvas.getBoundingClientRect();
                const state = this.floorCanvasStates[canvasId];

                const x = (e.clientX - rect.left - state.panX) / state.zoom;
                const y = (e.clientY - rect.top - state.panY) / state.zoom;

                const floor = this.floorData[floorNumber];
                if (!floor) return;

                // Select a turret
                let clickedTurret = floor.turrets.find(turret => {
                    const distance = Math.sqrt((x - turret.x) ** 2 + (y - turret.y) ** 2);
                    return distance <= 25;
                });

                if (clickedTurret) {
                    clearAllSelections(); // Clear all selections globally
                    clickedTurret.selected = true;
                    selectedTurret = clickedTurret; // Update global selectedTurret
                    this.selectedFloor = floorNumber; // Track which floor has the selection
                    updateSelectedInfo();
                    this.redrawFloorCanvasContent(canvasId, floorNumber);
                    draw(); // Redraw main canvas as well
                    return;
                }

                // Select a shape
                let clickedShape = floor.shapes.find(shape => {
                    if (shape.contains && shape.contains(x, y)) {
                        return true;
                    }
                    return false;
                });

                if (clickedShape) {
                    clearAllSelections();
                    clickedShape.selected = true;
                    selectedShape = clickedShape; // Update global selectedShape
                    this.selectedFloor = floorNumber;
                    updateSelectedInfo();
                    this.redrawFloorCanvasContent(canvasId, floorNumber);
                    draw();
                    return;
                }

                // Select an edge item (wall, window, etc.)
                const allEdgeItems = [
                    ...(floor.walls || []),
                    ...(floor.windows || []),
                    ...(floor.reinforcedWalls || []),
                    ...(floor.garageDoors || []),
                    ...(floor.securityGates || [])
                ];

                const clickedEdgeItem = allEdgeItems.find(item => {
                    if (!item.edge) return false;
                    const distance = distancePointToLine(x, y, item.edge);
                    return distance <= 10; // 10px tolerance
                });

                if (clickedEdgeItem) {
                    clearAllSelections();
                    clickedEdgeItem.selected = true;
                    this.selectedFloor = floorNumber;

                    // Update the correct global selected variable
                    if (floor.walls.includes(clickedEdgeItem)) selectedWall = clickedEdgeItem;
                    else if (floor.windows.includes(clickedEdgeItem)) selectedWindow = clickedEdgeItem;
                    else if (floor.reinforcedWalls && floor.reinforcedWalls.includes(clickedEdgeItem)) selectedReinforcedWall = clickedEdgeItem;
                    else if (floor.garageDoors && floor.garageDoors.includes(clickedEdgeItem)) selectedGarageDoor = clickedEdgeItem;
                    else if (floor.securityGates && floor.securityGates.includes(clickedEdgeItem)) selectedSecurityGate = clickedEdgeItem;

                    updateSelectedInfo();
                    this.redrawFloorCanvasContent(canvasId, floorNumber);
                    draw();
                    return;
                }

                // If no item is clicked, clear selections only on this floor
                clearFloorSelections(floor);
                // Also clear global selections if the previously selected item was on this floor
                clearGlobalSelectionsFromFloor(floor);
                this.redrawFloorCanvasContent(canvasId, floorNumber);
                draw(); // Redraw main canvas
                updateSelectedInfo();
            }

            handleFloorCanvasDrop(e, canvasId, floorNumber) {
                e.preventDefault();
                if (!draggedIcon) return;

                const canvas = document.getElementById(canvasId);
                const rect = canvas.getBoundingClientRect();
                const state = this.floorCanvasStates[canvasId];

                const x = (e.clientX - rect.left - state.panX) / state.zoom;
                const y = (e.clientY - rect.top - state.panY) / state.zoom;

                // Handle dropping turrets onto additional floors
                if (draggedIcon === 'turret') {
                    placeTurretDirectlyOnFloor(x, y, floorNumber);
                }
                // Add handling for other draggable items if needed
            }

            initializeFloorCanvas(canvasId, floorNumber) {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;

                const state = this.floorCanvasStates[canvasId];

                // Only initialize once
                if (state.initialized) {
                    this.redrawFloorCanvasContent(canvasId, floorNumber);
                    return;
                }

                // Set initial pan and zoom based on whether it's the main canvas or an additional floor
                if (canvasId === 'mapCanvas') {
                    state.panX = panX;
                    state.panY = panY;
                    state.zoom = zoom;
                } else {
                    // Additional floors start centered and zoomed out
                    state.panX = (canvas.width / 2) - (canvas.width / 2) / 1.0;
                    state.panY = (canvas.height / 2) - (canvas.height / 2) / 1.0;
                    state.zoom = 0.6; // Start with a more zoomed-out view for additional floors
                }

                // Event listeners for zooming and panning on additional floors
                canvas.addEventListener('wheel', (e) => {
                    this.handleFloorCanvasZoom(e, canvas, canvasId, floorNumber);
                });

                canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 1 || (e.ctrlKey && e.button === 0)) { // Middle click or Ctrl+Left click for panning
                        state.isPanningFloor = true;
                        state.lastFloorMouseX = e.clientX - canvas.getBoundingClientRect().left;
                        state.lastFloorMouseY = e.clientY - canvas.getBoundingClientRect().top;
                        canvas.style.cursor = 'grabbing';
                        e.preventDefault();
                    }
                });

                canvas.addEventListener('mousemove', (e) => {
                    this.handleFloorCanvasMouseMove(e, canvas, canvasId, floorNumber);
                });

                canvas.addEventListener('mouseup', () => {
                    if (state.isPanningFloor) {
                        state.isPanningFloor = false;
                        canvas.style.cursor = currentTool ? 'crosshair' : 'grab'; // Reset cursor
                    }
                });

                canvas.addEventListener('mouseleave', () => {
                    if (state.isPanningFloor) {
                        state.isPanningFloor = false;
                        canvas.style.cursor = currentTool ? 'crosshair' : 'grab'; // Reset cursor
                    }
                });

                // Click handling for selection and placement
                canvas.addEventListener('click', (e) => {
                    this.handleFloorCanvasClick(e, canvasId, floorNumber);
                    document.body.focus(); // Keep focus for global keyboard shortcuts
                });

                // Drag and drop for placing items onto floors
                canvas.addEventListener('dragover', (e) => {
                    e.preventDefault(); // Necessary to allow dropping
                    e.dataTransfer.dropEffect = 'copy';
                });

                canvas.addEventListener('drop', (e) => {
                    this.handleFloorCanvasDrop(e, canvasId, floorNumber);
                    document.body.focus();
                });

                // Mark as initialized
                state.initialized = true;
                this.redrawFloorCanvasContent(canvasId, floorNumber); // Initial draw
            }

            redrawAllFloorCanvases() {
                // Redraw main canvas
                draw();

                // Redraw additional floor canvases
                const floorCanvases = [2, 3, 4, 5];
                floorCanvases.forEach(floorNum => {
                    const canvasId = `floor${floorNum}Canvas`;
                    if (this.floorCanvasStates[canvasId] && this.floorCanvasStates[canvasId].initialized) {
                        this.redrawFloorCanvasContent(canvasId, floorNum);
                    }
                });
            }
        };

        window.FOVUtils = window.FOVUtils || {
            drawFOV: function(ctx, turret, gameState, isAllMode) {
                const { showLineOfSight, lineOfSightTurret, showAllTurrets, showTurretOverLimit, showTurretConnectedUnpowered, showTurretOffline } = gameState;
                const turretPos = { x: turret.x, y: turret.y };
                const viewRadius = 30 * PIXELS_PER_METER; // 30 meter range
                const numRays = 180; // More rays for smoother FOV

                // Calculate turret facing direction (rotation - 90 degrees)
                const facingAngle = turret.rotation - Math.PI / 2;
                const fovAngle = Math.PI; // 180 degree FOV cone
                const startAngle = facingAngle - fovAngle / 2;
                const endAngle = facingAngle + fovAngle / 2;

                // Determine FOV color based on turret status and mode
                let fovColor = 'rgba(255, 0, 0, 0.3)'; // Default red, slightly transparent
                let outlineColor = 'rgba(255, 0, 0, 0.8)';
                let outlineWidth = 2 / zoom; // Default outline width

                // Status checks based on turret power in tactical mode
                const isPowered = isTurretPowered(turret.number);
                const isOverLimit = isTurretOverLimit(turret.number);
                const isConnectedUnpowered = isTurretConnectedUnpowered(turret.number);

                let status = '';
                if (isOverLimit) {
                    status = 'OVERLOAD';
                    fovColor = 'rgba(255, 165, 0, 0.3)'; // Orange for overload
                    outlineColor = 'rgba(255, 165, 0, 0.8)';
                    outlineWidth = 3 / zoom;
                } else if (isConnectedUnpowered) {
                    status = 'UNPOWERED';
                    fovColor = 'rgba(100, 100, 100, 0.3)'; // Dark gray for unpowered
                    outlineColor = 'rgba(150, 150, 150, 0.8)';
                } else if (!isPowered) {
                    status = 'OFFLINE';
                    fovColor = 'rgba(128, 128, 128, 0.3)'; // Gray for offline
                    outlineColor = 'rgba(180, 180, 180, 0.8)';
                } else {
                    status = 'ONLINE';
                    fovColor = 'rgba(0, 255, 0, 0.3)'; // Green for online
                    outlineColor = 'rgba(0, 255, 0, 0.8)';
                }

                // If "Show All" mode or specific turret's FOV is requested
                if (isAllMode || (showLineOfSight && lineOfSightTurret === turret)) {
                    // Collect all blocking edges from shapes, walls, windows, doors etc.
                    const blockingEdges = [];

                    // Add edges from relevant floor data
                    const floorDataToUse = turret.floorNumber ? floorManager.floorData[turret.floorNumber] : floorManager.floorData[1]; // Use specific floor or main
                    if (!floorDataToUse) return;

                    // Add shape edges
                    if (floorDataToUse.shapes) {
                        floorDataToUse.shapes.forEach(shape => {
                            if (!shape.transparent && shape.getEdges) {
                                const edges = shape.getEdges();
                                edges.forEach(edge => blockingEdges.push(edge));
                            }
                        });
                    }

                    // Add wall edges
                    if (floorDataToUse.walls) {
                        floorDataToUse.walls.forEach(wall => {
                            if (!wall.transparent) {
                                blockingEdges.push(wall.edge);
                            }
                        });
                    }

                    // Add window edges
                    if (floorDataToUse.windows) {
                        floorDataToUse.windows.forEach(window => {
                            if (!window.transparent) {
                                blockingEdges.push(window.edge);
                            }
                        });
                    }

                    // Add reinforced wall edges (handle open/closed state)
                    if (floorDataToUse.reinforcedWalls) {
                        floorDataToUse.reinforcedWalls.forEach(wall => {
                            if (!wall.isOpen) { // If closed, block entire edge
                                blockingEdges.push(wall.edge);
                            } else { // If open, block segments
                                const gap = wall.getGapBounds();
                                blockingEdges.push({ start: wall.edge.start, end: gap.start });
                                blockingEdges.push({ start: gap.end, end: wall.edge.end });
                            }
                        });
                    }

                    // Add garage door edges (always block if present)
                    if (floorDataToUse.garageDoors) {
                        floorDataToUse.garageDoors.forEach(door => {
                            if (!door.isOpen) { // Only block if closed
                                blockingEdges.push(door.edge);
                            }
                        });
                    }

                    // Cast rays and find visibility boundary
                    const visibilityPoints = [];

                    for (let i = 0; i <= numRays; i++) {
                        const rayAngle = startAngle + (endAngle - startAngle) * (i / numRays);
                        const rayEnd = {
                            x: turretPos.x + Math.cos(rayAngle) * viewRadius,
                            y: turretPos.y + Math.sin(rayAngle) * viewRadius
                        };

                        let closestDistance = viewRadius;
                        let closestPoint = rayEnd;

                        // Check intersections with all blocking edges
                        for (const edge of blockingEdges) {
                            const intersection = lineIntersection(
                                turretPos, rayEnd,
                                edge.start, edge.end
                            );

                            if (intersection) {
                                const distance = Math.sqrt(
                                    Math.pow(intersection.x - turretPos.x, 2) +
                                    Math.pow(intersection.y - turretPos.y, 2)
                                );

                                if (distance < closestDistance) {
                                    closestDistance = distance;
                                    closestPoint = intersection;
                                }
                            }
                        }
                        visibilityPoints.push(closestPoint);
                    }

                    // Draw the FOV cone
                    if (visibilityPoints.length > 0) {
                        ctx.save();
                        ctx.fillStyle = fovColor;
                        ctx.strokeStyle = outlineColor;
                        ctx.lineWidth = outlineWidth;

                        ctx.beginPath();
                        ctx.moveTo(turretPos.x, turretPos.y);
                        visibilityPoints.forEach(point => {
                            ctx.lineTo(point.x, point.y);
                        });
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            }
        };
    </script>
    <style>
        body {
            margin: 0;
            padding: 5px;
            font-family: Arial, sans-serif;
            background: url('attached_assets/BG_1755735419614.png') center center, linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            background-size: cover;
            background-repeat: no-repeat;
            background-attachment: fixed;
            min-height: 100vh;
            color: #333;
        }

        .main-container {
            display: flex;
            gap: 20px;
            max-width: 1500px;
            margin: 0 auto;
            background: transparent;
        }

        .left-panel {
            display: flex;
            gap: 20px;
            background: transparent;
        }

        .toolbar {
            background: rgba(255, 255, 255, 0.9);
            padding: 8px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            width: 210px;
            position: relative;
            backdrop-filter: blur(10px);
        }

        .toolbar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            z-index: 1;
        }

        .toolbar > * {
            position: relative;
            z-index: 2;
        }

        .canvas-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 5px;
            min-width: 940px;
            backdrop-filter: blur(10px);
        }

        .sidebar-panel {
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            width: 200px;
        }

        canvas {
            border: 2px solid #ddd;
            cursor: crosshair;
            display: block;
        }

        .shape-buttons-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            row-gap: 4px;
            margin-bottom: 24px;
            margin-top:40px;
        }

        .shape-button {
            width: 100%;
            padding: 15px 4px;
            margin: 0;
            border: 2px solid var(--btn-color, #3498db);
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .shape-button:hover,
        .shape-button.active {
            background: var(--btn-color, #3498db);
            color: white;
        }

        /* Custom styling for Square and Triangle buttons with new artwork */
        #squareBtn, #triangleBtn {
            background: url('attached_assets/TextMode (4)_1755739881348.png') center center, linear-gradient(135deg, #4CAF50, #45a049);
            background-size: cover;
            color: #333;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
            font-weight: bold;
            border: none;
        }

        #squareBtn:hover, #triangleBtn:hover {
            background: url('attached_assets/TextMode (4)_1755739881348.png') center center;
            background-size: cover;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(127, 184, 0, 0.4);
            border: none;
        }

        #squareBtn.active, #triangleBtn.active {
            background: url('attached_assets/TextMode (3)_1755740084362.png') center center;
            background-size: cover;
            transform: scale(0.98);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
            border: none;
        }

        /* Custom styling for External Wall button with green metallic artwork */
        #square2Btn {
            background: url('attached_assets/greenTextMode_1755722918270.png') center center;
            background-size: cover;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            font-weight: bold;
            border: none;
        }

        #square2Btn:hover {
            background: url('attached_assets/greenTextMode_1755722918270.png') center center;
            background-size: cover;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 255, 0, 0.4);
            border: none;
        }

        #square2Btn.active {
            background: url('attached_assets/TextMode (3)_1755740084362.png') center center;
            background-size: cover;
            transform: scale(0.98);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
            border: none;
        }

        /* Custom green metallic button styling for remaining left column buttons */
        #windowBtn, #doorBtn {
            background: url('attached_assets/LeftIcons_1755714706936.png') center center;
            background-size: cover;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            font-weight: bold;
            border: none;
        }

        #windowBtn:hover, #doorBtn:hover {
            background: url('attached_assets/LeftIcons_1755714706936.png') center center;
            background-size: cover;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(127, 184, 0, 0.4);
            border: none;
        }

        #windowBtn.active, #doorBtn.active {
            background: url('attached_assets/TextMode (3)_1755740084362.png') center center;
            background-size: cover;
            transform: scale(0.98);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
            border: none;
        }

        /* Custom green metallic button styling for remaining right column buttons */
        #wallBtn, #reinforcedWallBtn, #securityGateBtn {
            background: url('attached_assets/rightIcons_1755715060385.png') center center;
            background-size: cover;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            font-weight: bold;
            border: none;
        }

        #wallBtn:hover, #reinforcedWallBtn:hover, #securityGateBtn:hover {
            background: url('attached_assets/rightIcons_1755715060385.png') center center;
            background-size: cover;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(127, 184, 0, 0.4);
            border: none;
        }

        #wallBtn.active, #reinforcedWallBtn.active, #securityGateBtn.active {
            background: url('attached_assets/TextMode (3)_1755740084362.png') center center;
            background-size: cover;
            transform: scale(0.98);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
            border: none;
        }

        /* Custom styling for Load Center, Show All Turret Views, and Erase All buttons with silver metallic artwork */
        #loadCenterBtn, #toggleAllBtn, #eraseAllBtn {
            background: url('attached_assets/Title_1755770024365.png') center center;
            background-size: contain;
            background-repeat: no-repeat;
            color: #333;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
            font-weight: bold;
            border: none;
        }

        #loadCenterBtn:hover, #toggleAllBtn:hover, #eraseAllBtn:hover {
            background: url('attached_assets/Title_1755770024365.png') center center;
            background-size: contain;
            background-repeat: no-repeat;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(192, 192, 192, 0.4);
            border: none;
        }

        #loadCenterBtn:active, #toggleAllBtn:active, #eraseAllBtn:active {
            background: url('attached_assets/Title_1755770024365.png') center center;
            background-size: contain;
            background-repeat: no-repeat;
            transform: scale(0.98);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
            border: none;
        }

        /* Custom save button styling */
        #saveMapBtn {
            background: url('attached_assets/Save_1755716088910.png') center center !important;
            background-size: contain !important;
            background-repeat: no-repeat !important;
            color: transparent !important;
            text-shadow: none !important;
            border: none !important;
        }

        #saveMapBtn:hover {
            background: url('attached_assets/Save_1755716088910.png') center center !important;
            background-size: contain !important;
            background-repeat: no-repeat !important;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(127, 184, 0, 0.4);
        }

        #saveMapBtn:active {
            background: url('attached_assets/Save_1755716088910.png') center center !important;
            background-size: contain !important;
            background-repeat: no-repeat !important;
            transform: scale(0.98);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }

        /* Custom manage button styling */
        #manageMapBtn {
            background: url('attached_assets/Settings_1755716339777.png') center center !important;
            background-size: contain !important;
            background-repeat: no-repeat !important;
            color: transparent !important;
            text-shadow: none !important;
            border: none !important;
        }

        #manageMapBtn:hover {
            background: url('attached_assets/Settings_1755716339777.png') center center !important;
            background-size: contain !important;
            background-repeat: no-repeat !important;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(127, 184, 0, 0.4);
        }

        #manageMapBtn:active {
            background: url('attached_assets/Settings_1755716339777.png') center center !important;
            background-size: contain !important;
            background-repeat: no-repeat !important;
            transform: scale(0.98);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }

        /* Custom load button styling */
        #loadMapBtn {
            background: url('attached_assets/Upload_1755716443974.png') center center !important;
            background-size: contain !important;
            background-repeat: no-repeat !important;
            color: transparent !important;
            text-shadow: none !important;
            border: none !important;
        }

        #loadMapBtn:hover {
            background: url('attached_assets/Upload_1755716443974.png') center center !important;
            background-size: contain !important;
            background-repeat: no-repeat !important;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(127, 184, 0, 0.4);
        }

        #loadMapBtn:active {
            background: url('attached_assets/Upload_1755716443974.png') center center !important;
            background-size: contain !important;
            background-repeat: no-repeat !important;
            transform: scale(0.98);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }

        /* Custom shape tools heading styling */
        .shape-tools-heading {
            background: url('attached_assets/TitleMain_1755719888093.png') center center;
            background-size: cover;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            font-weight: bold;
            padding: 27px 0px !important;
            margin: 0 0 0px 0;
            text-align: center;
            border-radius: 4px;
        }

        #shapetool-heading {
            padding-left: 76px;
            margin-top: 0px;
            margin-bottom: 13px;
            font-size: 1.07rem;
            }

        /* Custom heading underline styling */
        .heading-underline {
            background: url('attached_assets/Slider_1755722105593.png') center center;
            background-size: contain;
            background-repeat: no-repeat;
            height: 12px;
            width: 100%;
            margin: 5px 0 10px 0;
        }

        /* Custom header button styling */
        #mapEditorBtn, #tacticalMapBtn {
            background: url('attached_assets/greenTextMode_1755722918270.png') center center !important;
            background-size: cover !important;
            background-repeat: no-repeat !important;
            color: #fff !important;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8) !important;
            font-weight: bold !important;
            border: none !important;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        #mapEditorBtn:hover, #tacticalMapBtn:hover {
            background: url('attached_assets/greenTextMode_1755722918270.png') center center !important;
            background-size: cover !important;
            background-repeat: no-repeat !important;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(127, 184, 0, 0.4);
        }

        /* Active/selected state for mode buttons - yellow when selected */
        #mapEditorBtn.active, #tacticalMapBtn.active {
            background: url('attached_assets/TextMode (3)_1755740084362.png') center center !important;
            background-size: cover !important;
            background-repeat: no-repeat !important;
            color: #333 !important;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8) !important;
        }

        .floor-select-wrapper {
            position: relative;
            display: inline-block;
        }

        #floorSelect {
            background: url('attached_assets/greenTextMode_1755722918270.png') center center !important;
            background-size: cover !important;
            background-repeat: no-repeat !important;
            color: #fff !important;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8) !important;
            font-weight: bold !important;
            border: none !important;
            border-radius: 4px;
            padding-right: 30px !important;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        #floorSelect option {
            background: #2c3e50 !important;
            color: #fff !important;
            font-weight: bold;
            padding: 8px;
        }

        #floorSelect option:hover {
            background: #34495e !important;
        }

        #presetDropdown option {
            background: white !important;
            color: #333 !important;
        }

        #presetDropdown option:hover {
            background: #27ae60 !important;
        }

        /* Custom floor label styling */
        .floor-label {
            position: absolute;
            top: 24px;
            left: 50%;
            transform: translateX(-50%);
           /* background: url('attached_assets/Title_1755728543088.png') center center;*/
            background-size: cover;
            background-repeat: no-repeat;
            color: #333;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
            padding: 4px 12px;
            font-size: 24px;
            font-weight: bold;
            z-index: 20;
            border-radius: 2px;
            min-width: 65px;
            text-align: center;
        }

        /* Custom floor container styling */
        .floor-container {
            position: relative;
            background: url('attached_assets/NoTitle_1755734897205.png') center center !important;
            background-size: 100% 100% !important;
            background-repeat: no-repeat !important;
            padding: 35px 8px 36px 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 419px;
            height: 434px;
        }

        .floor-container canvas {
            border: none !important;
            background: #2a2a2a;
            border-radius: 8px;
        }

        /* Main floor container styling for larger canvas */
        .main-floor-container {
            position: relative;
            background: url('attached_assets/NoTitle_1755734897205.png') center center !important;
            background-size: 100% 100% !important;
            background-repeat: no-repeat !important;
            padding: 70px 50px 70px 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 762px;
            height: 829px;
        }

        .main-floor-container canvas {
            border: none !important;
            background: #2a2a2a;
            border-radius: 8px;
        }

        .floor-select-arrow {
            position: absolute;
            right: 21px;
            top: 52%;
            transform: translateY(-50%);
            color: white;
            font-size: 11px;
            pointer-events: none;
            z-index: 1;
        }

        #currentFloorIndicator {
            background: url('attached_assets/greenTextMode_1755722918270.png') center center !important;
            background-size: cover !important;
            background-repeat: no-repeat !important;
            color: #fff !important;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8) !important;
            font-weight: bold !important;
            border: none !important;
            border-radius: 4px;
        }

        h3 {
            margin-top: 0;
            color: #333;
        }

        .selected-info {
            margin-top: 15px;
            padding: 10px;
            background: #e3f2fd;
            border-radius: 4px;
            font-size: 12px;
        }

        .icon-item {
            background: url('attached_assets/IconMode (2)_1755740594418.png') center center;
            background-size: contain;
            background-repeat: no-repeat;
            border: none;
            border-radius: 4px;
            padding: 10px;
            margin: 5px 0;
            cursor: grab;
            text-align: center;
            transition: all 0.3s;
            user-select: none;
            width: 90px;
            height: 90px;
            justify-self: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-item:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(255, 165, 0, 0.4);
        }

        .icon-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .icon-svg {
            width: 45px;
            height: 45px;
            margin-bottom: 2px;
        }

        .icon-label {
            font-weight: bold;
            color: #333;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
            margin-top: 5px;
        }

        #toggleAllBtn:hover {
            opacity: 0.9;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }


        /* Floor dropdown styles */
        .floor-option:hover {
            background-color: #f8f9fa !important;
        }

        .floor-option.selected {
            background-color: #9b59b6 !important;
            color: white;
        }

        .tactical-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #2c3e50;
            z-index: 1000;
            display: none;
            padding: 20px;
            box-sizing: border-box;
        }

        .tactical-overlay.active {
            display: flex;
            flex-direction: column;
        }

        .tactical-header {
            background-color: #34495e;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tactical-title {
            font-size: 24px;
            font-weight: bold;
            color: #ecf0f1;
        }

        .tactical-content {
            flex: 1;
            background-color: #34495e;
            border-radius: 8px;
            padding: 20px;
            color: #ecf0f1;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 18px;
        }

        .turret-count-btn {
            background: #3498db !important;
            color: white !important;
            border: 2px solid #3498db !important;
            padding: 8px 16px;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .turret-count-btn:hover {
            background: #2980b9 !important;
            border-color: #2980b9 !important;
        }

        .turret-overload {
            background: #e74c3c !important;
            border-color: #e74c3c !important;
            animation: turret-overload-pulse 1.5s infinite ease-in-out;
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.7);
        }

        .turret-overload:hover {
            background: #c0392b !important;
            border-color: #c0392b !important;
        }

        @keyframes turret-overload-pulse {
            0% {
                box-shadow: 0 0 20px rgba(231, 76, 60, 0.8);
                transform: scale(1);
                background: #e74c3c !important;
                border-color: #e74c3c !important;
            }
            25% {
                box-shadow: 0 0 35px rgba(231, 76, 60, 1), 0 0 45px rgba(231, 76, 60, 0.6);
                transform: scale(1.08);
                background: #3498db !important;
                border-color: #3498db !important;
            }
            50% {
                box-shadow: 0 0 40px rgba(52, 152, 219, 1), 0 0 50px rgba(52, 152, 219, 0.7);
                transform: scale(1.1);
                background: #3498db !important;
                border-color: #3498db !important;
            }
            75% {
                box-shadow: 0 0 35px rgba(231, 76, 60, 1), 0 0 45px rgba(231, 76, 60, 0.6);
                transform: scale(1.08);
                background: #e74c3c !important;
                border-color: #e74c3c !important;
            }
            100% {
                box-shadow: 0 0 20px rgba(231, 76, 60, 0.8);
                transform: scale(1);
                background: #e74c3c !important;
                border-color: #e74c3c !important;
            }
        }


    </style>
</head>
<body>
    <div class="main-container">
        <div class="left-panel">
            <div class="toolbar">
                <h3 class="shape-tools-heading"><p id="shapetool-heading">Build Tiles</p></h3>
                <div class="shape-buttons-grid">
                <button class="shape-button" id="squareBtn" style="--btn-color: #3498db">Square</button>
                <button class="shape-button" id="triangleBtn" style="--btn-color: #3498db">Triangle</button>
                <button class="shape-button" id="square2Btn" style="--btn-color: #8B4513">External Wall</button>
                <button class="shape-button" id="wallBtn" style="--btn-color: #8B4513">Wall</button>
                <button class="shape-button" id="windowBtn" style="--btn-color: #8B4513">Window</button>
                <button class="shape-button" id="reinforcedWallBtn" style="--btn-color: #4A4A4A">Door Frame</button>
                <button class="shape-button" id="doorBtn" style="--btn-color: #666666">Garage Door</button>
                <button class="shape-button" id="securityGateBtn" style="--btn-color: #2C3E50">Posts</button>
                </div>

                <div style="margin-top: 15px;">
                    <button id="toggleAllBtn" style="width: 100%; padding: 10px; border-radius: 4px; cursor: pointer; transition: all 0.2s;">
                        Show All Turret Views
                    </button>
                </div>

                <div style="margin-top: 15px;">
                    <h4 style="margin: 0 0 2px 0; color: #333; text-align:center">Map Library</h4>
                    <div class="heading-underline"></div>
                    <div style="display: flex; gap: 5px;">
                        <button id="saveMapBtn" style="flex: 1; height: 60px; min-width: 40px; border-radius: 4px; cursor: pointer;">
                        </button>
                        <button id="loadMapBtn" style="flex: 1; height: 60px; min-width: 40px; border-radius: 4px; cursor: pointer;">
                        </button>
                        <button id="manageMapBtn" style="flex: 1; height: 60px; min-width: 40px; border-radius: 4px; cursor: pointer;">
                        </button>
                    </div>
                </div>

                <div style="margin-top: 15px;">
                    <button id="eraseAllBtn" style="width: 100%; padding: 10px; border-radius: 4px; cursor: pointer; transition: all 0.2s;">
                        Erase All
                    </button>
                </div>





                <div style="margin-top: 20px;">
                    <h4 style="margin: 0 0 2px 0; text-align:center">Components</h4>
                    <div class="heading-underline"></div>
                    <div class="icon-item" draggable="true" data-type="turret">
                        <svg width="50" height="50" viewBox="0 0 120 120">
                            <g transform="rotate(0 60 60)">
                                <rect x="57" y="35" width="6" height="26" fill="#555" stroke="#333" stroke-width="1"/>
                            </g>
                            <g transform="rotate(135 60 60)">
                                <rect x="57" y="35" width="6" height="26" fill="#555" stroke="#333" stroke-width="1"/>
                            </g>
                            <g transform="rotate(225 60 60)">
                                <rect x="57" y="35" width="6" height="26" fill="#555" stroke="#333" stroke-width="1"/>
                            </g>
                            <circle cx="60" cy="60" r="30" fill="#A57070" stroke="#444" stroke-width="3"/>
                            <polygon points="60,35 55,45 65,45" fill="#333"/>
                            <line x1="60" y1="60" x2="60" y2="45" stroke="#333" stroke-width="3"/>
                            <circle cx="60" cy="60" r="7" fill="#444"/>
                        </svg>
                    </div>
                </div>

                <div id="selectedInfo" class="selected-info" style="display: none;">
                    <strong>Selected:</strong> <span id="selectedType"></span><br>
                    <span id="rotationInfo" style="display: none;">
                        <strong>Rotation:</strong> <span id="selectedRotation"></span>°<br>
                    </span>
                    <span id="turretInfo" style="display: none;">
                        <strong>Line of Sight:</strong> <span id="losStatus"></span>
                    </span>
                </div>
            </div>

            <div class="canvas-container" style="display: flex; gap: 15px;">
                <div class="main-canvas-area" style="flex: 1;">
                    <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px;">
                    <button id="mapEditorBtn" class="header-select-btn active" style="padding: 18px 20px; border: 2px solid #3498db; background: #3498db; color: white; border-radius: 4px; cursor: pointer; font-weight: bold;">Map Editor</button>
                    <button id="tacticalMapBtn" class="header-select-btn" style="padding: 18px 15px; border: 2px solid #3498db; background: white; color: #3498db; border-radius: 4px; cursor: pointer; font-weight: bold;">Tactical Map</button>
                    <div class="floor-select-wrapper">
                        <select id="floorSelect" style="padding: 18px 32px; border: 2px solid #9b59b6; background: #9b59b6; color: white; border-radius: 4px; cursor: pointer; font-weight: bold;">
                            <option value="1">1 Floor</option>
                            <option value="3">3 Floors</option>
                            <option value="5" selected>5 Floors</option>
                            <option value="6">6 Floors</option>
                            <option value="9">9 Floors</option>
                        </select>
                        <div class="floor-select-arrow">▼</div>
                    </div>
                    <div id="currentFloorIndicator" style="padding: 17px 39px; background: #2ecc71; color: white; border-radius: 4px; font-weight: bold; margin-left: 1px;">Editing: 1st Floor</div>
                </div>
                    <div class="main-floor-container">
                        <div class="floor-label" style="text-align: center; margin-bottom: 25px; margin-top: 30px; font-weight: bold; color: #333; font-size: 32px;">Turret Control Map</div>
                        <canvas id="mapCanvas" width="700" height="700"></canvas>
                    </div>
                </div>

                <div id="additionalFloors" style="display: none; gap: 15px; width: auto;">
                    <!-- First column (floors 2-3) -->
                    <div style="display: flex; flex-direction: column; gap: 10px; width: 420px;">
                        <div class="floor-container">
                            <div class="floor-label">Roof</div>
                            <canvas id="floor2Canvas" width="350" height="349" style="cursor: pointer;"></canvas>
                        </div>
                        <div class="floor-container">
                            <div class="floor-label">2nd Floor</div>
                            <canvas id="floor3Canvas" width="350" height="349" style="cursor: pointer;"></canvas>
                        </div>
                    </div>

                    <!-- Second column (floors 4-5) for 5-floor layout -->
                    <div id="floors45Container" style="display: none; flex-direction: column; gap: 10px; width: 420px;">
                        <div class="floor-container">
                            <div class="floor-label">4th Floor</div>
                            <canvas id="floor4Canvas" width="350" height="349" style="cursor: pointer;"></canvas>
                        </div>
                        <div class="floor-container">
                            <div class="floor-label">3rd Floor</div>
                            <canvas id="floor5Canvas" width="350" height="349" style="cursor: pointer;"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>


    <script>
        // Centralized DOM element cache
        const elements = {
            canvas: document.getElementById('mapCanvas'),
            selectedInfo: document.getElementById('selectedInfo'),
            selectedType: document.getElementById('selectedType'),
            selectedRotation: document.getElementById('selectedRotation'),
            turretInfo: document.getElementById('turretInfo'),
            losStatus: document.getElementById('losStatus'),
            rotationInfo: document.getElementById('rotationInfo'),
            toggleAllBtn: document.getElementById('toggleAllBtn'),
            saveMapBtn: document.getElementById('saveMapBtn'),
            loadMapBtn: document.getElementById('loadMapBtn'),
            manageMapBtn: document.getElementById('manageMapBtn'),
            eraseAllBtn: document.getElementById('eraseAllBtn'),
            mapEditorBtn: document.getElementById('mapEditorBtn'),
            tacticalMapBtn: document.getElementById('tacticalMapBtn'),
            floorSelect: document.getElementById('floorSelect'),
            currentFloorIndicator: document.getElementById('currentFloorIndicator'),
            floor2Canvas: document.getElementById('floor2Canvas'),
            floor3Canvas: document.getElementById('floor3Canvas'),
            floor4Canvas: document.getElementById('floor4Canvas'),
            floor5Canvas: document.getElementById('floor5Canvas'),
            squareBtn: document.getElementById('squareBtn'),
            triangleBtn: document.getElementById('triangleBtn'),
            square2Btn: document.getElementById('square2Btn'),
            wallBtn: document.getElementById('wallBtn'),
            windowBtn: document.getElementById('windowBtn'),
            reinforcedWallBtn: document.getElementById('reinforcedWallBtn'),
            doorBtn: document.getElementById('doorBtn'),
            securityGateBtn: document.getElementById('securityGateBtn')
        };

        const canvas = elements.canvas;
        const ctx = canvas.getContext('2d');


        // Constants
        const SIDE_LENGTH = 3.5;
        const PIXELS_PER_METER = 40;
        const SIDE_PIXELS = SIDE_LENGTH * PIXELS_PER_METER;
        const SNAP_THRESHOLD = 150;

        // State
        let shapes = [];
        let turrets = [];
        let walls = [];
        let windows = [];
        let reinforcedWalls = [];
        let garageDoors = [];
        let securityGates = [];
        let selectedShape = null;
        let selectedTurret = null;
        let selectedWall = null;
        let selectedWindow = null;
        let selectedReinforcedWall = null;
        let selectedGarageDoor = null;
        let selectedSecurityGate = null;
        let currentTool = null;
        let ghostShape = null;
        let ghostWall = null;
        let ghostWindow = null;
        let ghostReinforcedWall = null;
        let ghostGarageDoor = null;
        let ghostSecurityGate = null;
        let mousePos = { x: 0, y: 0 };
        let snapEdge = null;
        let draggedIcon = null;
        let draggedTurret = null;
        let draggedFloorTurret = null;
        let draggedFloorNumber = null;
        let showLineOfSight = false;
        let lineOfSightTurret = null;
        let showAllTurrets = false;
        let zoom = 0.8;

        // Power container management now handled by TurretManager
        // Access via turretManager.powerContainers, turretManager.selectedContainer, etc.
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        let previewRotation = 0; // For External Wall preview rotation
        let tacticalModeActive = false; // Track tactical mode for grid colors

        // Initialize managers - ensure classes are loaded first
        let turretManager, floorManager, selectionManager, toolManager;
        
        // Wait for all classes to be available
        function initializeManagers() {
            try {
                turretManager = new (window.TurretManager || class TurretManager {
                    constructor() {
                        this.powerContainers = [];
                        this.selectedContainer = null;
                        this.containerError = null;
                        this.initialized = true;
                    }
                    getNextTurretNumber() { return 1; }
                    placeTurret() { return null; }
                    addPowerContainer() { return false; }
                    deletePowerContainer() {}
                    connectTurretToContainer() {}
                    disconnectTurretFromContainer() {}
                    getTurretStatus() { return 'OFFLINE'; }
                    initializeGlobalTurretCounter() {}
                    updateAllTurretNumbers() {}
                })();
                
                floorManager = new (window.FloorManager || class FloorManager {
                    constructor() {
                        this.floorData = {
                            1: { shapes: [], turrets: [], walls: [], windows: [], reinforcedWalls: [], garageDoors: [], securityGates: [] },
                            2: { shapes: [], turrets: [], walls: [], windows: [], reinforcedWalls: [], garageDoors: [], securityGates: [] },
                            3: { shapes: [], turrets: [], walls: [], windows: [], reinforcedWalls: [], garageDoors: [], securityGates: [] },
                            4: { shapes: [], turrets: [], walls: [], windows: [], reinforcedWalls: [], garageDoors: [], securityGates: [] },
                            5: { shapes: [], turrets: [], walls: [], windows: [], reinforcedWalls: [], garageDoors: [], securityGates: [] }
                        };
                        this.currentActiveFloor = 1;
                        this.currentFloors = 5;
                        this.floorCanvasStates = {};
                    }
                    redrawAllFloorCanvases() {}
                    initializeFloorCanvas() {}
                    handleFloorCanvasZoom() {}
                    handleFloorCanvasMouseMove() {}
                    handleFloorCanvasClick() {}
                    handleFloorCanvasDrop() {}
                    redrawFloorCanvasContent() {}
                })();
                
                selectionManager = new (window.SelectionManager || class SelectionManager {
                    constructor() {
                        this.selectedItem = null;
                        this.selectedType = null;
                        this.initialized = true;
                    }
                    selectItem(item, type) {
                        this.clearSelection();
                        this.selectedItem = item;
                        this.selectedType = type;
                        if (item) item.selected = true;
                    }
                    clearSelection() {
                        if (this.selectedItem) this.selectedItem.selected = false;
                        this.selectedItem = null;
                        this.selectedType = null;
                    }
                    getSelected() {
                        return { item: this.selectedItem, type: this.selectedType };
                    }
                    isSelected(item) {
                        return this.selectedItem === item;
                    }
                    hasSelection() {
                        return this.selectedItem !== null;
                    }
                })();
                
                toolManager = new (window.ToolManager || class ToolManager {
                    constructor() {
                        this.currentTool = null;
                        this.initialized = true;
                    }
                })();
                
                // Initialize canvas states with proper structure
                const canvases = [
                    { id: 'mapCanvas', floorNum: 1, isMain: true },
                    { id: 'floor2Canvas', floorNum: 2 },
                    { id: 'floor3Canvas', floorNum: 3 },
                    { id: 'floor4Canvas', floorNum: 4 },
                    { id: 'floor5Canvas', floorNum: 5 }
                ];

                canvases.forEach(({ id, floorNum, isMain }) => {
                    const canvas = document.getElementById(id);
                    if (canvas) {
                        // Initialize canvas state
                        floorManager.floorCanvasStates[id] = {
                            panX: isMain ? panX : 0,
                            panY: isMain ? panY : 0,
                            zoom: isMain ? zoom : 1.0,
                            initialized: false,
                            isPanningFloor: false,
                            lastFloorMouseX: 0,
                            lastFloorMouseY: 0
                        };
                        
                        // Add state directly to canvas for backward compatibility
                        canvas.floorState = {
                            isPanningFloor: false,
                            lastFloorMouseX: 0,
                            lastFloorMouseY: 0
                        };
                    }
                });
                
                console.log('Managers initialized successfully');
                return true;
            } catch (error) {
                console.error('Error initializing managers:', error);
                return false;
            }
        }
        
        // Initialize immediately
        initializeManagers();

        // Tool configuration using cached elements
        const toolButtons = {
            square: elements.squareBtn,
            triangle: elements.triangleBtn,
            square2: elements.square2Btn,
            wall: elements.wallBtn,
            window: elements.windowBtn,
            reinforcedWall: elements.reinforcedWallBtn,
            door: elements.doorBtn,
            securityGate: elements.securityGateBtn
        };

        // Utility functions
        function screenToWorld(x, y) {
            return {
                x: (x - panX) / zoom,
                y: (y - panY) / zoom
            };
        }

        function worldToScreen(x, y) {
            return {
                x: x * zoom + panX,
                y: y * zoom + panY
            };
        }

        function getWorldCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            return screenToWorld(screenX, screenY);
        }

        function updateZoomLevel() {
        }

        // DOM manipulation utilities
        function setElementText(elementName, text) {
            if (elements[elementName]) elements[elementName].textContent = text;
        }

        function setElementStyle(elementName, property, value) {
            if (elements[elementName]) elements[elementName].style[property] = value;
        }

        function setElementDisplay(elementName, display) {
            if (elements[elementName]) elements[elementName].style.display = display;
        }

        function setElementHTML(elementName, html) {
            if (elements[elementName]) elements[elementName].innerHTML = html;
        }

        // Utility function to redraw all floor canvases (now delegates to FloorManager)
        function redrawAllFloorCanvases() {
            floorManager.redrawAllFloorCanvases();
        }

        // Utility function to clear all selection variables
        function clearAllSelectionVariables() {
            selectedShape = selectedTurret = selectedWall = selectedWindow = selectedReinforcedWall = selectedGarageDoor = selectedSecurityGate = null;
        }

        // Utility function to clear floor selections
        function clearFloorSelections(floor) {
            if (floor.shapes) floor.shapes.forEach(item => item.selected = false);
            if (floor.turrets) floor.turrets.forEach(item => item.selected = false);
            if (floor.walls) floor.walls.forEach(item => item.selected = false);
            if (floor.windows) floor.windows.forEach(item => item.selected = false);
            if (floor.reinforcedWalls) floor.reinforcedWalls.forEach(item => item.selected = false);
            if (floor.garageDoors) floor.garageDoors.forEach(item => item.selected = false);
            if (floor.securityGates) floor.securityGates.forEach(item => item.selected = false);
        }

        // Utility function to clear global selections if from specific floor
        function clearGlobalSelectionsFromFloor(floor) {
            if (selectedShape && floor.shapes && floor.shapes.includes(selectedShape)) {
                selectedShape = null;
            }
            if (selectedTurret && floor.turrets && floor.turrets.includes(selectedTurret)) {
                selectedTurret = null;
            }
            if (selectedWall && floor.walls && floor.walls.includes(selectedWall)) {
                selectedWall = null;
            }
            if (selectedWindow && floor.windows && floor.windows.includes(selectedWindow)) {
                selectedWindow = null;
            }
            if (selectedReinforcedWall && floor.reinforcedWalls && floor.reinforcedWalls.includes(selectedReinforcedWall)) {
                selectedReinforcedWall = null;
            }
            if (selectedGarageDoor && floor.garageDoors && floor.garageDoors.includes(selectedGarageDoor)) {
                selectedGarageDoor = null;
            }
            if (selectedSecurityGate && floor.securityGates && floor.securityGates.includes(selectedSecurityGate)) {
                selectedSecurityGate = null;
            }
        }

        // Edge utilities
        const EdgeUtils = {
            distance(p1, p2) {
                return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
            },

            match(edge1, edge2, tolerance = 1) {
                const dist = EdgeUtils.distance;
                return (dist(edge1.start, edge2.start) < tolerance && dist(edge1.end, edge2.end) < tolerance) ||
                       (dist(edge1.start, edge2.end) < tolerance && dist(edge1.end, edge2.start) < tolerance);
            },

            coincide(edge1, edge2, tolerance = 15) {
                const dist = EdgeUtils.distance;
                const startToStart = dist(edge1.start, edge2.start);
                const startToEnd = dist(edge1.start, edge2.end);
                const endToStart = dist(edge1.end, edge2.start);
                const endToEnd = dist(edge1.end, edge2.end);

                const sameDirection = startToStart < tolerance && endToEnd < tolerance;
                const oppositeDirection = startToEnd < tolerance && endToStart < tolerance;

                if (sameDirection || oppositeDirection) {
                    const v1 = { x: edge1.end.x - edge1.start.x, y: edge1.end.y - edge1.start.y };
                    const v2 = { x: edge2.end.x - edge2.start.x, y: edge2.end.y - edge2.start.y };

                    const dot = v1.x * v2.x + v1.y * v2.y;
                    const len1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
                    const len2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);

                    return Math.abs(Math.abs(dot / (len1 * len2)) - 1) < 0.01;
                }

                return false;
            },

            existsOn(edge, items) {
                return items.some(item => EdgeUtils.match(item.edge, edge));
            }
        };

        // Alias for compatibility
        const distance = (p1, p2) => EdgeUtils.distance(p1, p2);
        const edgesMatch = (edge1, edge2, tolerance) => EdgeUtils.match(edge1, edge2, tolerance);
        const edgesCoincide = (edge1, edge2, tolerance) => EdgeUtils.coincide(edge1, edge2, tolerance);
        const anythingExistsOnEdge = (edge) => EdgeUtils.existsOn(edge, [...walls, ...windows, ...reinforcedWalls, ...garageDoors, ...securityGates]);



        // Selection management
        function deselectAll() {
            // Deselect items on main canvas
            [...shapes, ...turrets, ...walls, ...windows, ...reinforcedWalls, ...garageDoors, ...securityGates].forEach(item => item.selected = false);

            // Deselect items on all additional floors
            for (let floorNum = 2; floorNum <= 5; floorNum++) {
                const floor = floorManager.floorData[floorNum];
                if (floor) {
                    if (floor.shapes) floor.shapes.forEach(item => item.selected = false);
                    if (floor.turrets) floor.turrets.forEach(item => item.selected = false);
                    if (floor.walls) floor.walls.forEach(item => item.selected = false);
                    if (floor.windows) floor.windows.forEach(item => item.selected = false);
                    if (floor.reinforcedWalls) floor.reinforcedWalls.forEach(item => item.selected = false);
                    if (floor.garageDoors) floor.garageDoors.forEach(item => item.selected = false);
                    if (floor.securityGates) floor.securityGates.forEach(item => item.selected = false);
                }
            }
            clearAllSelectionVariables();
        }

        function selectItem(item, type) {
            // Clear only the previously selected item's visual state (don't clear all floors)
            if (selectedShape) selectedShape.selected = false;
            if (selectedTurret) selectedTurret.selected = false;
            if (selectedWall) selectedWall.selected = false;
            if (selectedWindow) selectedWindow.selected = false;
            if (selectedReinforcedWall) selectedReinforcedWall.selected = false;
            if (selectedGarageDoor) selectedGarageDoor.selected = false;
            if (selectedSecurityGate) selectedSecurityGate.selected = false;

            // Clear global selected variables
            clearAllSelectionVariables();

            // Set new selection
            item.selected = true;

            if (type === 'shape') selectedShape = item;
            else if (type === 'turret') selectedTurret = item;
            else if (type === 'wall') selectedWall = item;
            else if (type === 'window') selectedWindow = item;
            else if (type === 'reinforcedWall') selectedReinforcedWall = item;
            else if (type === 'garageDoor') selectedGarageDoor = item;
            else if (type === 'securityGate') selectedSecurityGate = item;

            updateSelectedInfo();
        }

        function getSelectedItem() {
            // First check global variables (main canvas selections)
            if (selectedTurret) return { item: selectedTurret, type: 'turret', floor: 1 };
            if (selectedShape) return { item: selectedShape, type: 'shape', floor: 1 };
            if (selectedWall) return { item: selectedWall, type: 'wall', floor: 1 };
            if (selectedWindow) return { item: selectedWindow, type: 'window', floor: 1 };
            if (selectedReinforcedWall) return { item: selectedReinforcedWall, type: 'reinforcedWall', floor: 1 };
            if (selectedGarageDoor) return { item: selectedGarageDoor, type: 'garageDoor', floor: 1 };
            if (selectedSecurityGate) return { item: selectedSecurityGate, type: 'securityGate', floor: 1 };

            // If nothing selected globally, search all additional floors
            for (let floorNum = 2; floorNum <= 5; floorNum++) {
                const floor = floorManager.floorData[floorNum];
                if (!floor) continue;

                if (floor.shapes) {
                    const selectedShape = floor.shapes.find(shape => shape.selected);
                    if (selectedShape) return { item: selectedShape, type: 'shape', floor: floorNum };
                }
                if (floor.turrets) {
                    const selectedTurret = floor.turrets.find(turret => turret.selected);
                    if (selectedTurret) return { item: selectedTurret, type: 'turret', floor: floorNum };
                }
                if (floor.walls) {
                    const selectedWall = floor.walls.find(wall => wall.selected);
                    if (selectedWall) return { item: selectedWall, type: 'wall', floor: floorNum };
                }
                if (floor.windows) {
                    const selectedWindow = floor.windows.find(window => window.selected);
                    if (selectedWindow) return { item: selectedWindow, type: 'window', floor: floorNum };
                }
                if (floor.reinforcedWalls) {
                    const selectedReinforcedWall = floor.reinforcedWalls.find(wall => wall.selected);
                    if (selectedReinforcedWall) return { item: selectedReinforcedWall, type: 'reinforcedWall', floor: floorNum };
                }
                if (floor.garageDoors) {
                    const selectedGarageDoor = floor.garageDoors.find(door => door.selected);
                    if (selectedGarageDoor) return { item: selectedGarageDoor, type: 'garageDoor', floor: floorNum };
                }
                if (floor.securityGates) {
                    const selectedSecurityGate = floor.securityGates.find(gate => gate.selected);
                    if (selectedSecurityGate) return { item: selectedSecurityGate, type: 'securityGate', floor: floorNum };
                }
            }

            return null;
        }

        // Tool selection
        function selectTool(toolName) {
            currentTool = toolName;
            ghostShape = null;
            ghostWall = null;
            ghostWindow = null;
            ghostReinforcedWall = null;
            ghostGarageDoor = null;
            ghostSecurityGate = null;

            if(typeof toolButtons !== "undefined") Object.entries(toolButtons).forEach(([tool, btn]) => {
                btn.classList.toggle('active', tool === toolName);
            });

            canvas.style.cursor = 'crosshair';
        }

        // Attach tool button listeners
        if(typeof toolButtons !== "undefined") Object.entries(toolButtons).forEach(([tool, btn]) => {
            btn.addEventListener('click', () => selectTool(tool));
        });

        // Shape classes
        class Shape {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.rotation = 0;
                this.selected = false;
                this.transparent = true; // Shapes default to transparent
            }

            contains(x, y) {
                return false;
            }

            getEdges() {
                return [];
            }

            getCenter() {
                return { x: this.x, y: this.y };
            }

            draw(ctx, isGhost = false, currentZoom = 1) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                if (isGhost) {
                    ctx.globalAlpha = 0.5;
                    ctx.strokeStyle = '#2ecc71';
                    ctx.lineWidth = 3 / currentZoom;
                    ctx.setLineDash([5 / currentZoom, 5 / currentZoom]);
                } else {
                    if (this.transparent) {
                        const fillColor = this.selected ? '#ff9999' : '#d0d0d0';

                        ctx.fillStyle = fillColor;
                        ctx.strokeStyle = this.selected ? '#cc6666' : '#a0a0a0';
                    } else {
                        ctx.fillStyle = this.selected ? '#e74c3c' : '#3498db';
                        ctx.strokeStyle = this.selected ? '#c0392b' : '#2980b9';
                    }
                    ctx.lineWidth = 2 / currentZoom;
                }

                this.drawShape(ctx, isGhost);

                ctx.restore();
            }
        }

        class Square extends Shape {
            constructor(x, y) {
                super(x, y, 'square');
            }

            drawShape(ctx, isGhost) {
                const half = SIDE_PIXELS / 2;
                ctx.beginPath();
                ctx.rect(-half, -half, SIDE_PIXELS, SIDE_PIXELS);
                if (!isGhost) ctx.fill();
                ctx.stroke();
            }

            contains(x, y) {
                const half = SIDE_PIXELS / 2;
                const dx = x - this.x;
                const dy = y - this.y;

                const cos = Math.cos(-this.rotation);
                const sin = Math.sin(-this.rotation);
                const rx = dx * cos - dy * sin;
                const ry = dx * sin + dy * cos;

                return Math.abs(rx) <= half && Math.abs(ry) <= half;
            }

            getEdges() {
                const half = SIDE_PIXELS / 2;
                const corners = [
                    { x: -half, y: -half },
                    { x: half, y: -half },
                    { x: half, y: half },
                    { x: -half, y: half }
                ];

                const worldCorners = corners.map(c => {
                    const cos = Math.cos(this.rotation);
                    const sin = Math.sin(this.rotation);
                    return {
                        x: this.x + c.x * cos - c.y * sin,
                        y: this.y + c.x * sin + c.y * cos
                    };
                });

                const edges = [];
                for (let i = 0; i < 4; i++) {
                    edges.push({
                        start: worldCorners[i],
                        end: worldCorners[(i + 1) % 4]
                    });
                }

                return edges;
            }
        }

        class Triangle extends Shape {
            constructor(x, y) {
                super(x, y, 'triangle');
            }

            drawShape(ctx, isGhost) {
                const height = SIDE_PIXELS * Math.sqrt(3) / 2;
                const half = SIDE_PIXELS / 2;
                const centroidOffset = height / 3;

                ctx.beginPath();
                ctx.moveTo(0, -height + centroidOffset);
                ctx.lineTo(-half, centroidOffset);
                ctx.lineTo(half, centroidOffset);
                ctx.closePath();

                if (!isGhost) ctx.fill();
                ctx.stroke();
            }

            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;

                const cos = Math.cos(-this.rotation);
                const sin = Math.sin(-this.rotation);
                const rx = dx * cos - dy * sin;
                const ry = dx * sin + dy * cos;

                const height = SIDE_PIXELS * Math.sqrt(3) / 2;
                const half = SIDE_PIXELS / 2;
                const centroidOffset = height / 3;

                const v0x = 0;
                const v0y = -height + centroidOffset;
                const v1x = -half;
                const v1y = centroidOffset;
                const v2x = half;
                const v2y = centroidOffset;

                const denominator = (v1y - v2y) * (v0x - v2x) + (v2x - v1x) * (v0y - v2y);
                const a = ((v1y - v2y) * (rx - v2x) + (v2x - v1x) * (ry - v2y)) / denominator;
                const b = ((v2y - v0y) * (rx - v2x) + (v0x - v2x) * (ry - v2y)) / denominator;
                const c = 1 - a - b;

                return a >= 0 && b >= 0 && c >= 0;
            }

            getEdges() {
                const height = SIDE_PIXELS * Math.sqrt(3) / 2;
                const half = SIDE_PIXELS / 2;
                const centroidOffset = height / 3;

                const corners = [
                    { x: 0, y: -height + centroidOffset },
                    { x: -half, y: centroidOffset },
                    { x: half, y: centroidOffset }
                ];

                const worldCorners = corners.map(c => {
                    const cos = Math.cos(this.rotation);
                    const sin = Math.sin(this.rotation);
                    return {
                        x: this.x + c.x * cos - c.y * sin,
                        y: this.y + c.x * sin + c.y * cos
                    };
                });

                const edges = [];
                for (let i = 0; i < 3; i++) {
                    edges.push({
                        start: worldCorners[i],
                        end: worldCorners[(i + 1) % 3]
                    });
                }

                return edges;
            }
        }

        class Square2 extends Shape {
            constructor(x, y) {
                super(x, y, "square2");
                this.width = 280; // 7 meters = 7 * 40 pixels/meter = 280 pixels
                this.height = 32; // 0.8 meters = 0.8 * 40 pixels/meter = 32 pixels
                this.transparent = false; // External walls should block turret vision
            }

            drawShape(ctx, isGhost) {
                const halfWidth = this.width / 2;
                const halfHeight = this.height / 2;

                ctx.beginPath();
                ctx.rect(-halfWidth, -halfHeight, this.width, this.height);

                if (!isGhost) {
                    ctx.fillStyle = this.selected ? '#CC7722' : '#8B4513';
                    ctx.fill();
                }

                ctx.strokeStyle = this.selected ? '#AA5511' : '#654321';
                ctx.stroke();
            }

            contains(x, y) {
                const halfWidth = this.width / 2;
                const halfHeight = this.height / 2;
                const dx = x - this.x;
                const dy = y - this.y;

                const cos = Math.cos(-this.rotation);
                const sin = Math.sin(-this.rotation);
                const rx = dx * cos - dy * sin;
                const ry = dx * sin + dy * cos;

                return Math.abs(rx) <= halfWidth && Math.abs(ry) <= halfHeight;
            }

            getEdges() {
                const halfWidth = this.width / 2;
                const halfHeight = this.height / 2;
                const corners = [
                    { x: -halfWidth, y: -halfHeight },
                    { x: halfWidth, y: -halfHeight },
                    { x: halfWidth, y: halfHeight },
                    { x: -halfWidth, y: halfHeight }
                ];

                const worldCorners = corners.map(c => {
                    const cos = Math.cos(this.rotation);
                    const sin = Math.sin(this.rotation);
                    return {
                        x: this.x + c.x * cos - c.y * sin,
                        y: this.y + c.x * sin + c.y * cos
                    };
                });

                const edges = [];
                for (let i = 0; i < 4; i++) {
                    edges.push({
                        start: worldCorners[i],
                        end: worldCorners[(i + 1) % 4]
                    });
                }

                return edges;
            }
        }

        // Turret class now loaded from js/classes/Turret.js

        // Edge-based items base class
        class EdgeItem {
            constructor(edge) {
                this.edge = {
                    start: { x: edge.start.x, y: edge.start.y },
                    end: { x: edge.end.x, y: edge.end.y }
                };
                this.selected = false;
            }

            contains(x, y) {
                const dist = this.distanceToPoint(x, y);
                return dist <= this.hitRadius / zoom;
            }

            distanceToPoint(px, py) {
                const {start, end} = this.edge;
                const A = px - start.x, B = py - start.y;
                const C = end.x - start.x, D = end.y - start.y;
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                const param = lenSq !== 0 ? Math.max(0, Math.min(1, dot / lenSq)) : 0;

                const xx = start.x + param * C;
                const yy = start.y + param * D;
                return Math.sqrt((px - xx) ** 2 + (py - yy) ** 2);
            }

            getCenter() {
                return {
                    x: (this.edge.start.x + this.edge.end.x) / 2,
                    y: (this.edge.start.y + this.edge.end.y) / 2
                };
            }
        }

        class Wall extends EdgeItem {
            constructor(edge) {
                super(edge);
                this.hitRadius = 10;
            }

            draw(ctx, isGhost = false, currentZoom = 1) {
                ctx.save();

                ctx.strokeStyle = isGhost ? '#8B4513' : (this.selected ? '#CD853F' : '#8B4513');
                ctx.lineWidth = 8 / currentZoom;
                ctx.lineCap = 'round';

                if (isGhost) {
                    ctx.globalAlpha = 0.5;
                    ctx.setLineDash([5 / currentZoom, 5 / currentZoom]);
                }

                ctx.beginPath();
                ctx.moveTo(this.edge.start.x, this.edge.start.y);
                ctx.lineTo(this.edge.end.x, this.edge.end.y);
                ctx.stroke();

                if (!isGhost) {
                    ctx.strokeStyle = this.selected ? '#A0522D' : '#654321';
                    ctx.lineWidth = 5 / currentZoom;
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.moveTo(this.edge.start.x, this.edge.start.y);
                    ctx.lineTo(this.edge.end.x, this.edge.end.y);
                    ctx.stroke();

                    ctx.fillStyle = '#8B4513';
                    ctx.globalAlpha = 0.2;
                    const numSpots = 3;
                    for (let i = 1; i <= numSpots; i++) {
                        const t = i / (numSpots + 1);
                        const spotX = this.edge.start.x + t * (this.edge.end.x - this.edge.start.x);
                        const spotY = this.edge.start.y + t * (this.edge.end.y - this.edge.start.y);
                        ctx.beginPath();
                        ctx.arc(spotX, spotY, 3 / currentZoom, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                ctx.restore();
            }
        }


        class WindowTool extends EdgeItem {
            constructor(edge) {
                super(edge);
                this.hitRadius = 10;
            }

            draw(ctx, isGhost = false, currentZoom = 1) {
                ctx.save();

                // Window appearance - identical to walls with same colors
                ctx.strokeStyle = isGhost ? '#8B4513' : (this.selected ? '#CD853F' : '#8B4513');
                ctx.lineWidth = 8 / currentZoom;
                ctx.lineCap = 'round';

                if (isGhost) {
                    ctx.globalAlpha = 0.5;
                    ctx.setLineDash([5 / currentZoom, 5 / currentZoom]);
                }

                ctx.beginPath();
                ctx.moveTo(this.edge.start.x, this.edge.start.y);
                ctx.lineTo(this.edge.end.x, this.edge.end.y);
                ctx.stroke();

                if (!isGhost) {
                    ctx.strokeStyle = this.selected ? '#A0522D' : '#654321';
                    ctx.lineWidth = 5 / currentZoom;
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.moveTo(this.edge.start.x, this.edge.start.y);
                    ctx.lineTo(this.edge.end.x, this.edge.end.y);
                    ctx.stroke();

                    ctx.fillStyle = '#8B4513';
                    ctx.globalAlpha = 0.2;
                    const numSpots = 3;
                    for (let i = 1; i <= numSpots; i++) {
                        const t = i / (numSpots + 1);
                        const spotX = this.edge.start.x + t * (this.edge.end.x - this.edge.start.x);
                        const spotY = this.edge.start.y + t * (this.edge.end.y - this.edge.start.y);
                        ctx.beginPath();
                        ctx.arc(spotX, spotY, 3 / currentZoom, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                ctx.restore();
            }
        }

        class ReinforcedWall extends EdgeItem {
            constructor(edge) {
                super(edge);
                this.hitRadius = 10;
                this.gapSize = 1.5 * PIXELS_PER_METER; // 1.5 meter gap
                this.isOpen = false; // Start closed by default
            }

            getGapBounds() {
                const center = this.getCenter();
                const dx = this.edge.end.x - this.edge.start.x;
                const dy = this.edge.end.y - this.edge.start.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                const unitX = dx / len;
                const unitY = dy / len;

                const halfGap = this.gapSize / 2;

                return {
                    start: {
                        x: center.x - unitX * halfGap,
                        y: center.y - unitY * halfGap
                    },
                    end: {
                        x: center.x + unitX * halfGap,
                        y: center.y + unitY * halfGap
                    }
                };
            }

            draw(ctx, isGhost = false, currentZoom = 1) {
                ctx.save();

                const gap = this.getGapBounds();

                // Draw the two wall segments (with gap in middle)
                ctx.strokeStyle = isGhost ? '#4A4A4A' : (this.selected ? '#666666' : '#4A4A4A');
                ctx.lineWidth = 8 / currentZoom;
                ctx.lineCap = 'round';

                if (isGhost) {
                    ctx.globalAlpha = 0.5;
                    ctx.setLineDash([5 / currentZoom, 5 / currentZoom]);
                }

                // First segment (start to gap start)
                ctx.beginPath();
                ctx.moveTo(this.edge.start.x, this.edge.start.y);
                ctx.lineTo(gap.start.x, gap.start.y);
                ctx.stroke();

                // Second segment (gap end to end)
                ctx.beginPath();
                ctx.moveTo(gap.end.x, gap.end.y);
                ctx.lineTo(this.edge.end.x, this.edge.end.y);
                ctx.stroke();

                if (!isGhost) {
                    // Inner line for depth effect
                    ctx.strokeStyle = this.selected ? '#333333' : '#2C2C2C';
                    ctx.lineWidth = 5 / currentZoom;
                    ctx.globalAlpha = 0.7;

                    ctx.beginPath();
                    ctx.moveTo(this.edge.start.x, this.edge.start.y);
                    ctx.lineTo(gap.start.x, gap.start.y);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(gap.end.x, gap.end.y);
                    ctx.lineTo(this.edge.end.x, this.edge.end.y);
                    ctx.stroke();

                    // Draw door in the gap
                    const center = this.getCenter();

                    // Door frame posts
                    ctx.fillStyle = '#555';
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1 / currentZoom;
                    ctx.globalAlpha = 1;

                    const postRadius = 3 / currentZoom;

                    ctx.beginPath();
                    ctx.arc(gap.start.x, gap.start.y, postRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(gap.end.x, gap.end.y, postRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Door line
                    ctx.strokeStyle = '#999';
                    ctx.lineWidth = 1 / currentZoom;
                    ctx.setLineDash([2 / currentZoom, 2 / currentZoom]);
                    ctx.beginPath();
                    ctx.moveTo(gap.start.x, gap.start.y);
                    ctx.lineTo(gap.end.x, gap.end.y);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Open/Closed text
                    let angle = Math.atan2(gap.end.y - gap.start.y, gap.end.x - gap.start.x);

                    if (angle > Math.PI / 2 || angle < -Math.PI / 2) {
                        angle += Math.PI;
                    }

                    ctx.save();
                    ctx.translate(center.x, center.y);
                    ctx.rotate(angle);

                    ctx.font = `bold ${10 / currentZoom}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    if (this.isOpen) {
                        const textMetrics = ctx.measureText('OPEN');
                        const textWidth = textMetrics.width;
                        const textHeight = 12 / currentZoom;

                        ctx.fillStyle = '#1B5E20';
                        ctx.fillRect(-textWidth/2 - 3/currentZoom, -textHeight/2, textWidth + 6/currentZoom, textHeight);

                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2 / currentZoom;
                        ctx.strokeText('OPEN', 0, 0);

                        ctx.fillStyle = this.selected ? '#4CAF50' : '#2E7D32';
                        ctx.fillText('OPEN', 0, 0);
                    } else {
                        const textMetrics = ctx.measureText('CLOSED');
                        const textWidth = textMetrics.width;
                        const textHeight = 12 / currentZoom;

                        ctx.fillStyle = '#B71C1C';
                        ctx.fillRect(-textWidth/2 - 3/currentZoom, -textHeight/2, textWidth + 6/currentZoom, textHeight);

                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2 / currentZoom;
                        ctx.strokeText('CLOSED', 0, 0);

                        ctx.fillStyle = this.selected ? '#F44336' : '#C62828';
                        ctx.fillText('CLOSED', 0, 0);
                    }

                    ctx.restore();

                    // Metal reinforcement pattern on wall segments
                    ctx.strokeStyle = '#888888';
                    ctx.lineWidth = 1 / currentZoom;
                    ctx.globalAlpha = 0.5;

                    const dx = this.edge.end.x - this.edge.start.x;
                    const dy = this.edge.end.y - this.edge.start.y;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    const nx = -dy / len * 4; // normal vector
                    const ny = dx / len * 4;

                    // Draw cross-hatch pattern on first segment
                    const segment1Len = Math.sqrt((gap.start.x - this.edge.start.x) ** 2 + (gap.start.y - this.edge.start.y) ** 2);
                    const numStripes1 = Math.floor(segment1Len / 20);
                    for (let i = 1; i < numStripes1; i++) {
                        const t = i / numStripes1;
                        const x = this.edge.start.x + t * (gap.start.x - this.edge.start.x);
                        const y = this.edge.start.y + t * (gap.start.y - this.edge.start.y);

                        ctx.beginPath();
                        ctx.moveTo(x - nx, y - ny);
                        ctx.lineTo(x + nx, y + ny);
                        ctx.stroke();
                    }

                    // Draw cross-hatch pattern on second segment
                    const segment2Len = Math.sqrt((this.edge.end.x - gap.end.x) ** 2 + (this.edge.end.y - gap.end.y) ** 2);
                    const numStripes2 = Math.floor(segment2Len / 20);
                    for (let i = 1; i < numStripes2; i++) {
                        const t = i / numStripes2;
                        const x = gap.end.x + t * (this.edge.end.x - gap.end.x);
                        const y = gap.end.y + t * (this.edge.end.y - gap.end.y);

                        ctx.beginPath();
                        ctx.moveTo(x - nx, y - ny);
                        ctx.lineTo(x + nx, y + ny);
                        ctx.stroke();
                    }
                }

                ctx.restore();
            }
        }

        class GarageDoor extends EdgeItem {
            constructor(edge, isOpen) {
                super(edge);
                this.isOpen = isOpen;
                this.hitRadius = 12;
            }

            draw(ctx, isGhost = false, currentZoom = 1) {
                ctx.save();

                const { start, end } = this.edge;
                const postRadius = 5 / currentZoom;

                ctx.fillStyle = isGhost ? '#666' : (this.selected ? '#888' : '#555');
                ctx.strokeStyle = isGhost ? '#444' : (this.selected ? '#666' : '#333');
                ctx.lineWidth = 1 / currentZoom;

                if (isGhost) {
                    ctx.globalAlpha = 0.5;
                }

                ctx.beginPath();
                ctx.arc(start.x, start.y, postRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(end.x, end.y, postRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1 / currentZoom;
                ctx.setLineDash([3 / currentZoom, 3 / currentZoom]);
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();
                ctx.setLineDash([]);

                const midX = (start.x + end.x) / 2;
                const midY = (start.y + end.y) / 2;

                let angle = Math.atan2(end.y - start.y, end.x - start.x);

                if (angle > Math.PI / 2 || angle < -Math.PI / 2) {
                    angle += Math.PI;
                }

                ctx.save();
                ctx.translate(midX, midY);
                ctx.rotate(angle);

                ctx.font = `bold ${12 / currentZoom}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                if (this.isOpen) {
                    const textMetrics = ctx.measureText('OPEN');
                    const textWidth = textMetrics.width;
                    const textHeight = 16 / currentZoom;

                    ctx.fillStyle = '#1B5E20';
                    ctx.fillRect(-textWidth/2 - 4/currentZoom, -textHeight/2, textWidth + 8/currentZoom, textHeight);

                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2.5 / currentZoom;
                    ctx.strokeText('OPEN', 0, 0);

                    ctx.fillStyle = this.selected ? '#4CAF50' : '#2E7D32';
                    ctx.fillText('OPEN', 0, 0);
                } else {
                    const textMetrics = ctx.measureText('CLOSED');
                    const textWidth = textMetrics.width;
                    const textHeight = 16 / currentZoom;

                    ctx.fillStyle = '#B71C1C';
                    ctx.fillRect(-textWidth/2 - 4/currentZoom, -textHeight/2, textWidth + 8/currentZoom, textHeight);

                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2.5 / currentZoom;
                    ctx.strokeText('CLOSED', 0, 0);

                    ctx.fillStyle = this.selected ? '#F44336' : '#C62828';
                    ctx.fillText('CLOSED', 0, 0);
                }

                ctx.restore();
                ctx.restore();
            }
        }

        class SecurityGate extends EdgeItem {
            constructor(edge) {
                super(edge);
                this.hitRadius = 14;
            }

            draw(ctx, isGhost = false, currentZoom = 1) {
                ctx.save();

                const { start, end } = this.edge;
                const postRadius = 7 / currentZoom;

                // Darker, more industrial colors
                ctx.fillStyle = isGhost ? '#2C3E50' : (this.selected ? '#34495E' : '#2C3E50');
                ctx.strokeStyle = isGhost ? '#1A252F' : (this.selected ? '#2C3E50' : '#1A252F');
                ctx.lineWidth = 2 / currentZoom;

                if (isGhost) {
                    ctx.globalAlpha = 0.5;
                }

                // Larger posts with metal texture
                ctx.beginPath();
                ctx.arc(start.x, start.y, postRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Inner ring for metal effect
                ctx.beginPath();
                ctx.arc(start.x, start.y, postRadius * 0.6, 0, Math.PI * 2);
                ctx.strokeStyle = '#95A5A6';
                ctx.lineWidth = 1 / currentZoom;
                ctx.stroke();

                ctx.fillStyle = isGhost ? '#2C3E50' : (this.selected ? '#34495E' : '#2C3E50');
                ctx.strokeStyle = isGhost ? '#1A252F' : (this.selected ? '#2C3E50' : '#1A252F');
                ctx.lineWidth = 2 / currentZoom;

                ctx.beginPath();
                ctx.arc(end.x, end.y, postRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Inner ring for second post
                ctx.beginPath();
                ctx.arc(end.x, end.y, postRadius * 0.6, 0, Math.PI * 2);
                ctx.strokeStyle = '#95A5A6';
                ctx.lineWidth = 1 / currentZoom;
                ctx.stroke();

                ctx.restore();
            }
        }

        // Help modal generation
        function createHelpModal() {
            const helpContent = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>Map Editor Guide</h2>
                        <button class="close-button" id="closeModal">&times;</button>
                    </div>

                    <div class="modal-section">
                        <h3>🎯 Overview</h3>
                        <p>Create tactical maps with shapes and turrets. Build defensive structures and visualize sight lines.</p>
                    </div>

                    <div class="modal-section">
                        <h3>🔷 Shapes & Walls</h3>
                        <ul>
                            <li>Click <strong>Square</strong> or <strong>Triangle</strong> button to select tool</li>
                            <li>Click on canvas to place shape</li>
                            <li>Shapes auto-snap to edges of existing shapes</li>
                            <li>Squares can rotate to align with triangle edges</li>
                            <li>Each side = 3.5 meters</li>
                            <li><strong>Default:</strong> Shapes are grey (transparent) and DON'T block line of sight</li>
                            <li><strong>Right-click shape:</strong> Toggle blocking - blue shapes block sight, grey shapes don't</li>
                            <li><strong>Walls:</strong> Click Wall button, then click near a shape edge to place</li>
                            <li>Walls are rusty metal colored and ALWAYS block line of sight</li>
                        </ul>
                    </div>

                    <div class="modal-section">
                        <h3>🚪 Garage Doors</h3>
                        <ul>
                            <li>Click <strong>Garage Door</strong> button to select tool</li>
                            <li>Click near a shape edge to place door (like walls)</li>
                            <li>Doors are placed in the <strong>CLOSED</strong> state by default (red text)</li>
                            <li><strong>Right-click any door</strong> to toggle between open/closed states</li>
                            <li><strong>Open Doors:</strong> Show "OPEN" in green text - does NOT block line of sight</li>
                            <li><strong>Closed Doors:</strong> Show "CLOSED" in red text - BLOCKS line of sight</li>
                            <li>Posts are placed at edge endpoints (3.5m apart)</li>
                            <li>Only one wall/door allowed per edge</li>
                        </ul>
                    </div>

                    <div class="modal-section">
                        <h3>🔫 Turrets</h3>
                        <ul>
                            <li>Drag turret from right panel onto canvas</li>
                            <li>Click turret to toggle its 180° line of sight</li>
                            <li>Red area shows what turret can see</li>
                            <li>Turret range: 30 meters</li>
                            <li>Click and drag to reposition turrets</li>
                        </ul>
                    </div>

                    <div class="modal-section">
                        <h3>⌨️ Keyboard Shortcuts</h3>
                        <ul>
                            <li><span class="shortcut">R</span> - Rotate selected shape (30°) or turret (45°)</li>
                            <li><span class="shortcut">L</span> - Toggle line of sight for selected turret</li>
                            <li><span class="shortcut">A</span> - Show/hide all turret views</li>
                            <li><span class="shortcut">Delete</span> - Remove selected item</li>
                            <li><span class="shortcut">Left-click</span> + drag - Pan the canvas</li>
                            <li><span class="shortcut">?</span> - Open this help menu</li>
                            <li><span class="shortcut">Escape</span> - Close this help menu</li>
                            <li><span class="shortcut">Mouse Wheel</span> - Zoom in/out</li>
                        </ul>
                    </div>

                    <div class="modal-section">
                        <h3>🖱️ Mouse Controls</h3>
                        <ul>
                            <li><strong>Left-click</strong> - Select or place items</li>
                            <li><strong>Right-click shape</strong> - Toggle blocking (grey = transparent, blue = blocks sight)</li>
                            <li><strong>Right-click door</strong> - Toggle between open/closed state</li>
                            <li><strong>Right-click empty</strong> - Cancel current tool</li>
                        </ul>
                    </div>

                    <div class="modal-section">
                        <h3>💡 Tips</h3>
                        <ul>
                            <li>Shapes start as grey (transparent) by default - they don't block sight</li>
                            <li>Right-click shapes to make them blue (opaque) - these block turret sight</li>
                            <li>Walls (rusty metal) ALWAYS block turret sight lines</li>
                            <li>Garage doors start closed (red) - right-click to open them</li>
                            <li>Doors show "OPEN" (green) or "CLOSED" (red) text between posts</li>
                            <li>Right-click doors to quickly toggle between open/closed states</li>
                            <li>Closed doors block sight, open doors don't</li>
                            <li>Use "Show All Turret Views" to see total coverage</li>
                            <li>Overlapping red areas show redundant coverage</li>
                            <li>Look for gaps in coverage to find blind spots</li>
                        </ul>
                    </div>
                </div>
            `;

            helpModal.innerHTML = helpContent;

            // Add close button handler
            document.getElementById('closeModal').addEventListener('click', () => {
                helpModal.style.display = 'none';
            });
        }

        // Generate turret SVG
        function generateTurretSVG() {
            const svg = document.getElementById('turretIcon');
            if (svg) {
                svg.innerHTML = turretManager.generateTurretSVG();
            }
        }

        // Selection info configuration
        const selectionInfoConfig = {
            turret: {
                getName: () => 'Turret',
                hasRotation: true,
                hasTurretInfo: true,
                getStatus: (item) => {
                    return turretManager.getTurretStatus(item, { showAllTurrets, showLineOfSight, lineOfSightTurret }, {
                        isTurretPowered,
                        isTurretOverLimit,
                        isTurretConnectedUnpowered
                    });
                }
            },
            shape: {
                getName: (item) => {
                    const name = item.type.charAt(0).toUpperCase() + item.type.slice(1);
                    return name + (item.transparent ? ' (Transparent)' : ' (Blocks Sight)');
                },
                hasRotation: true
            },
            wall: {
                getName: () => 'Wall (3.5m)'
            },
            reinforcedWall: {
                getName: (item) => item.isOpen ? 'Open Door Frame (1.5m)' : 'Closed Door Frame (1.5m)'
            },
            garageDoor: {
                getName: (item) => item.isOpen ? 'Open Door (3.5m)' : 'Closed Door (3.5m)'
            },
            securityGate: {
                getName: () => 'Posts (3.5m apart)'
            }
        };

        function updateSelectedInfo() {
            const selected = getSelectedItem();

            if (!selected) {
                setElementDisplay('selectedInfo', 'none');
                return;
            }

            const config = selectionInfoConfig[selected.type];
            setElementDisplay('selectedInfo', 'block');
            setElementText('selectedType', config.getName(selected.item));

            setElementDisplay('rotationInfo', config.hasRotation ? 'block' : 'none');
            if (config.hasRotation) {
                const degrees = Math.round((selected.item.rotation * 180 / Math.PI) % 360);
                setElementText('selectedRotation', degrees < 0 ? degrees + 360 : degrees);
            }

            setElementDisplay('turretInfo', config.hasTurretInfo ? 'block' : 'none');
            if (config.hasTurretInfo) {
                setElementText('losStatus', config.getStatus(selected.item));
            }
        }

        // Core algorithms (keeping original logic intact)
        function checkOverlap(newShape, shapes) {
            for (const shape of shapes) {
                const dist = Math.sqrt((newShape.x - shape.x) ** 2 + (newShape.y - shape.y) ** 2);
                const minDist = shape.type === 'triangle' || newShape.type === 'triangle' ? SIDE_PIXELS * 0.6 : SIDE_PIXELS * 0.8;
                if (dist < minDist) {
                    return true;
                }
            }
            return false;
        }

        function lineIntersection(p1, p2, p3, p4) {
            const denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
            if (Math.abs(denom) < 0.0001) return null;

            const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;
            const ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denom;

            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
                return {
                    x: p1.x + ua * (p2.x - p1.x),
                    y: p1.y + ua * (p2.y - p1.y),
                    distance: ua
                };
            }
            return null;
        }

        function castRay(origin, angle, shapes, excludeShape) {
            const maxDist = 2000;
            const endpoint = {
                x: origin.x + Math.cos(angle) * maxDist,
                y: origin.y + Math.sin(angle) * maxDist
            };

            let closestIntersection = null;
            let closestDistance = maxDist;

            for (const shape of shapes) {
                if (shape === excludeShape || (shape.transparent && !(shape instanceof Square2))) continue;

                const edges = shape.getEdges();
                for (const edge of edges) {
                    const intersection = lineIntersection(origin, endpoint, edge.start, edge.end);
                    if (intersection) {
                        const dist = Math.sqrt((intersection.x - origin.x) ** 2 + (intersection.y - origin.y) ** 2);
                        if (dist < closestDistance) {
                            closestDistance = dist;
                            closestIntersection = intersection;
                        }
                    }
                }
            }

            for (const wall of walls) {
                const intersection = lineIntersection(origin, endpoint, wall.edge.start, wall.edge.end);
                if (intersection) {
                    const dist = Math.sqrt((intersection.x - origin.x) ** 2 + (intersection.y - origin.y) ** 2);
                    if (dist < closestDistance) {
                        closestDistance = dist;
                        closestIntersection = intersection;
                    }
                }
            }

            for (const window of windows) {
                const intersection = lineIntersection(origin, endpoint, window.edge.start, window.edge.end);
                if (intersection) {
                    const dist = Math.sqrt((intersection.x - origin.x) ** 2 + (intersection.y - origin.y) ** 2);
                    if (dist < closestDistance) {
                        closestDistance = dist;
                        closestIntersection = intersection;
                    }
                }
            }

            for (const wall of reinforcedWalls) {
                // If the door in the frame is closed, block the entire edge
                if (!wall.isOpen) {
                    const intersection = lineIntersection(origin, endpoint, wall.edge.start, wall.edge.end);
                    if (intersection) {
                        const dist = Math.sqrt((intersection.x - origin.x) ** 2 + (intersection.y - origin.y) ** 2);
                        if (dist < closestDistance) {
                            closestDistance = dist;
                            closestIntersection = intersection;
                        }
                    }
                } else {
                    // If open, only block the wall segments, not the gap
                    const gap = wall.getGapBounds();

                    // Check first segment (start to gap start)
                    const intersection1 = lineIntersection(origin, endpoint, wall.edge.start, gap.start);
                    if (intersection1) {
                        const dist = Math.sqrt((intersection1.x - origin.x) ** 2 + (intersection1.y - origin.y) ** 2);
                        if (dist < closestDistance) {
                            closestDistance = dist;
                            closestIntersection = intersection1;
                        }
                    }

                    // Check second segment (gap end to end)
                    const intersection2 = lineIntersection(origin, endpoint, gap.end, wall.edge.end);
                    if (intersection2) {
                        const dist = Math.sqrt((intersection2.x - origin.x) ** 2 + (intersection2.y - origin.y) ** 2);
                        if (dist < closestDistance) {
                            closestDistance = dist;
                            closestIntersection = intersection2;
                        }
                    }
                }
            }

            for (const door of garageDoors) {
                if (!door.isOpen) {
                    const intersection = lineIntersection(origin, endpoint, door.edge.start, door.edge.end);
                    if (intersection) {
                        const dist = Math.sqrt((intersection.x - origin.x) ** 2 + (intersection.y - origin.y) ** 2);
                        if (dist < closestDistance) {
                            closestDistance = dist;
                            closestIntersection = intersection;
                        }
                    }
                }
            }

            // Security gates don't block line of sight - they're just posts

            return closestIntersection || endpoint;
        }

        function findSnapPosition(shape, shapes) {
            if (shapes.length === 0) return null;

            let minDist = Infinity;
            let bestSnap = null;
            let bestRotation = 0;
            let bestSnapEdge = null;

            const rotationSteps = 12;
            const rotationIncrement = (Math.PI * 2) / rotationSteps;

            for (let rot = 0; rot < rotationSteps; rot++) {
                const testRotation = rot * rotationIncrement;

                const originalRotation = shape.rotation;
                shape.rotation = testRotation;
                const newEdges = shape.getEdges();
                shape.rotation = originalRotation;

                for (const existingShape of shapes) {
                    const existingEdges = existingShape.getEdges();

                    for (const newEdge of newEdges) {
                        for (const existingEdge of existingEdges) {
                            const newVector = {
                                x: newEdge.end.x - newEdge.start.x,
                                y: newEdge.end.y - newEdge.start.y
                            };
                            const existingVector = {
                                x: existingEdge.end.x - existingEdge.start.x,
                                y: existingEdge.end.y - existingEdge.start.y
                            };

                            const newLength = Math.sqrt(newVector.x ** 2 + newVector.y ** 2);
                            const existingLength = Math.sqrt(existingVector.x ** 2 + existingVector.y ** 2);

                            if (Math.abs(newLength - existingLength) < 1) {
                                const alignments = [
                                    {
                                        x: existingEdge.start.x - newEdge.start.x,
                                        y: existingEdge.start.y - newEdge.start.y
                                    },
                                    {
                                        x: existingEdge.end.x - newEdge.end.x,
                                        y: existingEdge.end.y - newEdge.end.y
                                    },
                                    {
                                        x: existingEdge.start.x - newEdge.end.x,
                                        y: existingEdge.start.y - newEdge.end.y
                                    },
                                    {
                                        x: existingEdge.end.x - newEdge.start.x,
                                        y: existingEdge.end.y - newEdge.start.y
                                    }
                                ];

                                for (const offset of alignments) {
                                    const originalX = shape.x;
                                    const originalY = shape.y;
                                    const originalRot = shape.rotation;

                                    shape.x += offset.x;
                                    shape.y += offset.y;
                                    shape.rotation = testRotation;

                                    const testEdges = shape.getEdges();

                                    let validPlacement = false;
                                    let snapEdgeFound = null;
                                    for (const testEdge of testEdges) {
                                        for (const checkEdge of existingEdges) {
                                            if (edgesCoincide(testEdge, checkEdge)) {
                                                validPlacement = true;
                                                snapEdgeFound = checkEdge;
                                                break;
                                            }
                                        }
                                        if (validPlacement) break;
                                    }

                                    if (validPlacement) {
                                        const dist = Math.sqrt(offset.x ** 2 + offset.y ** 2);
                                        if (dist < minDist && dist < SNAP_THRESHOLD * 2) {
                                            minDist = dist;
                                            bestSnap = { x: shape.x, y: shape.y };
                                            bestRotation = testRotation;
                                            bestSnapEdge = snapEdgeFound;
                                        }
                                    }

                                    shape.x = originalX;
                                    shape.y = originalY;
                                    shape.rotation = originalRot;
                                }
                            }
                        }
                    }
                }
            }

            return bestSnap ? { position: bestSnap, rotation: bestRotation, edge: bestSnapEdge } : null;
        }

        function findNearestEdge(x, y) {
            let minDist = Infinity;
            let nearestEdge = null;

            shapes.forEach(shape => {
                const edges = shape.getEdges();
                edges.forEach(edge => {
                    const midX = (edge.start.x + edge.end.x) / 2;
                    const midY = (edge.start.y + edge.end.y) / 2;
                    const dist = Math.sqrt((x - midX) ** 2 + (y - midY) ** 2);

                    if (dist < minDist && dist < SNAP_THRESHOLD) {
                        minDist = dist;
                        nearestEdge = edge;
                    }
                });
            });

            return nearestEdge;
        }

        function collectBlockingVertices() {
            const vertices = [];

            // Regular blocking shapes and walls
            const basicBlockingSources = [
                ...shapes.filter(s => !s.transparent).flatMap(s => s.getEdges()),
                ...walls.map(w => w.edge),
                ...windows.map(w => w.edge),
                ...garageDoors.filter(d => !d.isOpen).map(d => d.edge)
            ];

            basicBlockingSources.forEach(edge => {
                vertices.push(edge.start, edge.end);
            });

            // Special handling for reinforced walls (door frames)
            reinforcedWalls.forEach(wall => {
                if (!wall.isOpen) {
                    // If closed, the entire edge blocks
                    vertices.push(wall.edge.start, wall.edge.end);
                } else {
                    // If open, only the segments block
                    const gap = wall.getGapBounds();
                    vertices.push(wall.edge.start, gap.start);
                    vertices.push(gap.end, wall.edge.end);
                }
            });

            return vertices;
        }

        function normalizeAngle(angle) {
            while (angle > Math.PI) angle -= 2 * Math.PI;
            while (angle < -Math.PI) angle += 2 * Math.PI;
            return angle;
        }

        function drawLineOfSight(ctx, turret, currentZoom, isAllMode = false) {
            if (!turret) return;

            const gameState = { shapes, walls, windows, reinforcedWalls, garageDoors, showLineOfSight, lineOfSightTurret, showAllTurrets };
            FOVUtils.drawFOV(ctx, turret, gameState, isAllMode);
        }

        // Event handlers
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;

            if (isPanning) {
                panX += screenX - lastMouseX;
                panY += screenY - lastMouseY;
                lastMouseX = screenX;
                lastMouseY = screenY;
                draw();
                return;
            }

            const worldCoords = screenToWorld(screenX, screenY);
            mousePos.x = worldCoords.x;
            mousePos.y = worldCoords.y;

            if (draggedTurret) {
                draggedTurret.x = mousePos.x;
                dragdraggedTurret.y = mousePos.y;
                draw();
                return;
            }

            if (currentTool === 'wall' || currentTool === 'window' || currentTool === 'reinforcedWall' || currentTool === 'door' || currentTool === 'securityGate') {
                if (shapes.length === 0) {
                    canvas.style.cursor = 'not-allowed';
                } else {
                    const nearestEdge = findNearestEdge(mousePos.x, mousePos.y);
                    if (nearestEdge && !anythingExistsOnEdge(nearestEdge)) {
                        if (currentTool === 'wall') {
                            ghostWall = new Wall(nearestEdge);
                        } else if (currentTool === "window") {
                            ghostWindow = new WindowTool(nearestEdge);
                        } else if (currentTool === 'reinforcedWall') {
                            ghostReinforcedWall = new ReinforcedWall(nearestEdge);
                        } else if (currentTool === 'door') {
                            ghostGarageDoor = new GarageDoor(nearestEdge, false);
                        } else if (currentTool === 'securityGate') {
                            ghostSecurityGate = new SecurityGate(nearestEdge);
                        }
                        canvas.style.cursor = 'pointer';
                    } else {
                        ghostWall = null;
                        ghostWindow = null;
                        ghostReinforcedWall = null;
                        ghostGarageDoor = null;
                        ghostSecurityGate = null;
                        canvas.style.cursor = 'crosshair';
                    }
                }
                draw();
            } else if (currentTool) {
                if (currentTool === 'square') {
                    ghostShape = new Square(mousePos.x, mousePos.y);
                } else if (currentTool === 'triangle') {
                    ghostShape = new Triangle(mousePos.x, mousePos.y);
                } else if (currentTool === "square2") {
                    ghostShape = new Square2(mousePos.x, mousePos.y);
                    ghostShape.rotation = previewRotation; // Apply preview rotation
                }

                if (shapes.length > 0 && ghostShape && currentTool !== "square2") {
                    const snapResult = findSnapPosition(ghostShape, shapes);
                    if (snapResult) {
                        ghostShape.x = snapResult.position.x;
                        ghostShape.y = snapResult.position.y;
                        ghostShape.rotation = snapResult.rotation;
                        snapEdge = snapResult.edge;
                        canvas.style.cursor = 'pointer';
                    } else {
                        ghostShape.rotation = 0;
                        snapEdge = null;
                        canvas.style.cursor = 'crosshair';
                    }
                } else {
                    snapEdge = null;
                }

                draw();
            }
        }

        function handleToolClick(coords) {
            const toolHandlers = {
                wall: () => placeEdgeItem(coords.x, coords.y, Wall, walls),
                window: () => placeEdgeItem(coords.x, coords.y, WindowTool, windows),
                reinforcedWall: () => placeEdgeItem(coords.x, coords.y, (edge) => new ReinforcedWall(edge), reinforcedWalls),
                door: () => placeEdgeItem(coords.x, coords.y, (edge) => new GarageDoor(edge, false), garageDoors),
                securityGate: () => placeEdgeItem(coords.x, coords.y, SecurityGate, securityGates),
                square: () => placeShape(coords.x, coords.y, Square),
                triangle: () => placeShape(coords.x, coords.y, Triangle),
                square2: () => placeExternalWall(coords.x, coords.y),
                turret: () => placeTurret(coords.x, coords.y)
            };

            const handler = toolHandlers[currentTool];
            if (handler) handler();
        }

        function placeEdgeItem(x, y, ItemClass, collection) {
            if (shapes.length === 0) return;

            const nearestEdge = findNearestEdge(x, y);
            if (nearestEdge && !anythingExistsOnEdge(nearestEdge)) {
                const newItem = typeof ItemClass === 'function' && ItemClass.prototype ?
                    new ItemClass(nearestEdge) : ItemClass(nearestEdge);
                collection.push(newItem);
                draw();
            }
        }

        function placeShape(x, y, ShapeClass) {
            const newShape = new ShapeClass(x, y);
            let canPlace = true;

            if (shapes.length > 0) {
                const snapResult = findSnapPosition(newShape, shapes);
                if (snapResult) {
                    newShape.x = snapResult.position.x;
                    newShape.y = snapResult.position.y;
                    newShape.rotation = snapResult.rotation;
                } else {
                    canPlace = !checkOverlap(newShape, shapes);
                }
            }

            if (canPlace) {
                shapes.push(newShape);
                snapEdge = null;
                draw();
            }
        }

        function handleSelectionClick(coords) {
            const clickChecks = [
                { items: turrets, type: 'turret', handler: handleTurretClick },
                { items: walls, type: 'wall' },
                { items: windows, type: "window" },
                { items: reinforcedWalls, type: 'reinforcedWall' },
                { items: garageDoors, type: 'garageDoor' },
                { items: securityGates, type: 'securityGate' },
                { items: shapes, type: 'shape' }
            ];

            for (const {items, type, handler} of clickChecks) {
                let clicked = null;
                for (let i = items.length - 1; i >= 0; i--) {
                    if (items[i].contains(coords.x, coords.y)) {
                        clicked = items[i];
                        break;
                    }
                }
                if (clicked) {
                    if (handler) {
                        handler(clicked);
                    } else {
                        selectItem(clicked, type);
                        draw();
                    }
                    return;
                }
            }

            // Clear selections only on main canvas (floor 1)
            [...shapes, ...turrets, ...walls, ...windows, ...reinforcedWalls, ...garageDoors, ...securityGates].forEach(item => item.selected = false);

            // Clear global selected variables only if the selected item was from main canvas
            let foundOnMainCanvas = false;
            if (selectedShape && shapes.includes(selectedShape)) {
                selectedShape = null;
                foundOnMainCanvas = true;
            }
            if (selectedTurret && turrets.includes(selectedTurret)) {
                selectedTurret = null;
                foundOnMainCanvas = true;
            }
            if (selectedWall && walls.includes(selectedWall)) {
                selectedWall = null;
                foundOnMainCanvas = true;
            }
            if (selectedWindow && windows.includes(selectedWindow)) {
                selectedWindow = null;
                foundOnMainCanvas = true;
            }
            if (selectedReinforcedWall && reinforcedWalls.includes(selectedReinforcedWall)) {
                selectedReinforcedWall = null;
                foundOnMainCanvas = true;
            }
            if (selectedGarageDoor && garageDoors.includes(selectedGarageDoor)) {
                selectedGarageDoor = null;
                foundOnMainCanvas = true;
            }
            if (selectedSecurityGate && securityGates.includes(selectedSecurityGate)) {
                selectedSecurityGate = null;
                foundOnMainCanvas = true;
            }

            draw();
            if (foundOnMainCanvas) {
                updateSelectedInfo();
            }
        }

        function handleTurretClick(turret) {
            const gameState = { showAllTurrets, showLineOfSight, lineOfSightTurret };
            const callbacks = {
                selectItem,
                clearAllSelections: () => {
                    [...shapes, ...turrets, ...walls, ...windows, ...reinforcedWalls, ...garageDoors, ...securityGates].forEach(item => item.selected = false);
                    clearAllSelectionVariables();
                },
                updateSelectedInfo,
                draw
            };

            turretManager.handleTurretClick(turret, gameState, callbacks);

            // Update global state
            showLineOfSight = gameState.showLineOfSight;
            lineOfSightTurret = gameState.lineOfSightTurret;
        }

        function handleMouseClick(e) {
            const coords = getWorldCoords(e);

            if (currentTool) {
                handleToolClick(coords);
            } else {
                handleSelectionClick(coords);
            }
        }

        function handleRightClick(e) {
            e.preventDefault();

            const coords = getWorldCoords(e);



            // Check for turret click first (for tactical mode functionality)
            if (tacticalModeActive) {
                for (let i = turrets.length - 1; i >= 0; i--) {
                    if (turrets[i].contains(coords.x, coords.y)) {
                        const menuX = e.clientX;
                        const menuY = e.clientY;
                        showTurretConnectionMenu(menuX, menuY, turrets[i].number);
                        return;
                    }
                }
            }

            // Check for door frame (reinforced wall) click first
            let clickedDoorFrame = null;
            for (let i = reinforcedWalls.length - 1; i >= 0; i--) {
                if (reinforcedWalls[i].contains(coords.x, coords.y)) {
                    clickedDoorFrame = reinforcedWalls[i];
                    break;
                }
            }

            if (clickedDoorFrame) {
                clickedDoorFrame.isOpen = !clickedDoorFrame.isOpen;
                if (clickedDoorFrame === selectedReinforcedWall) {
                    updateSelectedInfo();
                }
                draw();
                return;
            }

            // Check for garage door click
            let clickedDoor = null;
            for (let i = garageDoors.length - 1; i >= 0; i--) {
                if (garageDoors[i].contains(coords.x, coords.y)) {
                    clickedDoor = garageDoors[i];
                    break;
                }
            }

            if (clickedDoor) {
                clickedDoor.isOpen = !clickedDoor.isOpen;
                if (clickedDoor === selectedGarageDoor) {
                    updateSelectedInfo();
                }
                draw();
                return;
            }

            // Check for shape click
            let clickedShape = null;
            for (let i = shapes.length - 1; i >= 0; i--) {
                if (shapes[i].contains(coords.x, coords.y)) {
                    clickedShape = shapes[i];
                    break;
                }
            }

            if (clickedShape) {
                // Right-click on shapes does nothing
                return;
            } else {
                currentTool = null;
                ghostShape = null;
                ghostWall = null;
                ghostWindow = null;
                ghostReinforcedWall = null;
                ghostGarageDoor = null;
                ghostSecurityGate = null;
                snapEdge = null;
                Object.values(toolButtons).forEach(btn => btn.classList.remove('active'));
                canvas.style.cursor = isPanning ? 'grab' : 'default';
                draw();
            }
        }

        // Keyboard handling
        const keyActions = {
            'Delete': {
                action: () => {
                    const selected = getSelectedItem();
                    if (!selected) {
                        return;
                    }

                    if (selected.type === 'turret') {
                        if (lineOfSightTurret === selected.item) {
                            showLineOfSight = false;
                            lineOfSightTurret = null;
                        }
                        if (selected.floor === 1) {
                            // Delete from main canvas
                            const index = turrets.indexOf(selected.item);
                            if (index > -1) {
                                turrets.splice(index, 1);
                                updateFloorIndicator(floorManager.currentActiveFloor);
                            }
                        } else {
                            // Delete from specific floor
                            const floor = floorManager.floorData[selected.floor];
                            if (floor && floor.turrets) {
                                const index = floor.turrets.indexOf(selected.item);
                                if (index > -1) {
                                    floor.turrets.splice(index, 1);
                                }
                            }
                        }

                        // Update global turret numbering after any turret deletion
                        updateAllTurretNumbers();

                        // Redraw floor canvases to reflect changes
                        if (document.getElementById('floor2Canvas')) {
                            redrawFloorCanvasContent('floor2Canvas', 2);
                        }
                        if (document.getElementById('floor3Canvas')) {
                            redrawFloorCanvasContent('floor3Canvas', 3);
                        }
                    } else if (selected.type === 'shape') {
                        if (selected.floor === 1) {
                            // Delete from main canvas
                            const index = shapes.indexOf(selected.item);
                            if (index > -1) {
                                shapes.splice(index, 1);
                                cleanupOrphanedEdgeItems();
                            }
                        } else {
                            // Delete from specific floor
                            const floor = floorManager.floorData[selected.floor];
                            if (floor && floor.shapes) {
                                const index = floor.shapes.indexOf(selected.item);
                                if (index > -1) {
                                    floor.shapes.splice(index, 1);

                                    // Redraw the specific floor canvas
                                    const canvasId = `floor${selected.floor}Canvas`;
                                    if (document.getElementById(canvasId)) {
                                        redrawFloorCanvasContent(canvasId, selected.floor);
                                    }
                                }
                            }
                        }
                    } else if (selected.type === 'wall') {
                        const index = walls.indexOf(selected.item);
                        if (index > -1) walls.splice(index, 1);
                    } else if (selected.type === 'reinforcedWall') {
                        const index = reinforcedWalls.indexOf(selected.item);
                        if (index > -1) reinforcedWalls.splice(index, 1);
                    } else if (selected.type === 'garageDoor') {
                        const index = garageDoors.indexOf(selected.item);
                        if (index > -1) garageDoors.splice(index, 1);
                    } else if (selected.type === 'securityGate') {
                        const index = securityGates.indexOf(selected.item);
                        if (index > -1) securityGates.splice(index, 1);
                    }

                    // Clear selections only on main canvas after deletion
                    [...shapes, ...turrets, ...walls, ...windows, ...reinforcedWalls, ...garageDoors, ...securityGates].forEach(item => item.selected = false);
                    clearAllSelectionVariables();

                    updateSelectedInfo();
                    draw();
                }
            },
            'r': {
                action: () => {
                    if (selectedTurret) {
                        selectedTurret.rotation += Math.PI / 4;

                        // Redraw floor canvases if this is a floor turret
                        if (selectedTurret.floorNumber && selectedTurret.floorNumber > 1) {
                            if (selectedTurret.floorNumber === 2 && document.getElementById('floor2Canvas')) {
                                redrawFloorCanvasContent('floor2Canvas', 2);
                            }
                            if (selectedTurret.floorNumber === 3 && document.getElementById('floor3Canvas')) {
                                redrawFloorCanvasContent('floor3Canvas', 3);
                            }
                        }
                    } else if (selectedShape) {
                        selectedShape.rotation += Math.PI / 6;
                    } else if (currentTool === "square2") {
                        // Rotate External Wall preview
                        previewRotation += Math.PI / 6; // 30-degree increments
                        if (previewRotation >= Math.PI * 2) previewRotation = 0;
                        draw(); // Redraw to show rotated preview
                        return; // Don't call updateSelectedInfo for preview
                    }
                    updateSelectedInfo();
                    draw();
                },
                caseSensitive: false
            },
            'l': {
                action: () => {
                    const selected = getSelectedItem();
                    let currentTurret = selectedTurret;

                    // Check for floor turrets if no main canvas turret selected
                    if (!currentTurret && selected && selected.type === 'turret') {
                        currentTurret = selected.item;
                    }

                    // Find any selected turret from any floor
                    if (!currentTurret) {
                        for (let floorNum = 2; floorNum <= 5; floorNum++) {
                            const floor = floorManager.floorData[floorNum];
                            if (floor && floor.turrets) {
                                const floorTurret = floor.turrets.find(t => t.selected);
                                if (floorTurret) {
                                    currentTurret = floorTurret;
                                    break;
                                }
                            }
                        }
                    }

                    if (!currentTurret) return;

                    if (lineOfSightTurret === currentTurret && showLineOfSight) {
                        showLineOfSight = false;
                        lineOfSightTurret = null;
                    } else {
                        showLineOfSight = true;
                        lineOfSightTurret = currentTurret;
                        showAllTurrets = false;
                    }

                    redrawAllFloorCanvases();
                    updateSelectedInfo();
                    draw();
                },
                caseSensitive: false
            },
            'a': {
                action: () => {
                    showAllTurrets = !showAllTurrets;

                    if (showAllTurrets) {
                        setElementText('toggleAllBtn', 'Hide All Turret Views');
                        setElementStyle('toggleAllBtn', 'background', '#27ae60');
                        showLineOfSight = false;
                        lineOfSightTurret = null;
                    } else {
                        setElementText('toggleAllBtn', 'Show All Turret Views');
                        setElementStyle('toggleAllBtn', 'background', '#e74c3c');
                    }

                    // Redraw all floor canvases to update FOV display
                    redrawAllFloorCanvases();
                    updateSelectedInfo();
                    draw();
                },
                caseSensitive: false
            },
            ' ': {
                action: (e) => {
                    e.preventDefault();
                    isPanning = true;
                    canvas.style.cursor = 'grab';
                }
            }
        };

        function handleKeyDown(e) {
            const key = e.key;
            const keyLower = key.toLowerCase();
            const action = keyActions[key] || (keyActions[keyLower] && !keyActions[keyLower].caseSensitive && keyActions[keyLower]);

            if (action && (!action.condition || action.condition())) {
                action.action(e);
            }
        }

        function handleKeyUp(e) {
            if (e.key === ' ') {
                isPanning = false;
                canvas.style.cursor = currentTool ? 'crosshair' : 'default';
            }
        }

        // Consolidate edge item cleanup using utility function
        function filterEdgeItemsByShapeEdges(items) {
            return items.filter(item => {
                for (const shape of shapes) {
                    const edges = shape.getEdges();
                    for (const edge of edges) {
                        if (edgesMatch(item.edge, edge)) return true;
                    }
                }
                return false;
            });
        }

        function cleanupOrphanedEdgeItems() {
            walls = filterEdgeItemsByShapeEdges(walls);
            reinforcedWalls = filterEdgeItemsByShapeEdges(reinforcedWalls);
            garageDoors = filterEdgeItemsByShapeEdges(garageDoors);
            securityGates = filterEdgeItemsByShapeEdges(securityGates);
        }

        // Drawing functions
        function drawGrid() {
            ctx.strokeStyle = tacticalModeActive ? '#666666' : '#f0f0f0';
            ctx.lineWidth = 1 / zoom;
            const gridStart = Math.floor(-panX / zoom / PIXELS_PER_METER) * PIXELS_PER_METER;
            const gridEnd = Math.ceil((canvas.width - panX) / zoom / PIXELS_PER_METER) * PIXELS_PER_METER;

            for (let x = gridStart; x <= gridEnd; x += PIXELS_PER_METER) {
                ctx.beginPath();
                ctx.moveTo(x, -panY / zoom);
                ctx.lineTo(x, (canvas.height - panY) / zoom);
                ctx.stroke();
            }

            const gridStartY = Math.floor(-panY / zoom / PIXELS_PER_METER) * PIXELS_PER_METER;
            const gridEndY = Math.ceil((canvas.height - panY) / zoom / PIXELS_PER_METER) * PIXELS_PER_METER;

            for (let y = gridStartY; y <= gridEndY; y += PIXELS_PER_METER) {
                ctx.beginPath();
                ctx.moveTo(-panX / zoom, y);
                ctx.lineTo((canvas.width - panX) / zoom, y);
                ctx.stroke();
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();

            ctx.translate(panX, panY);
            ctx.scale(zoom, zoom);

            drawGrid();



            // Draw center dot for alignment verification (blue dot at center of main canvas)
            ctx.save();
            ctx.fillStyle = '#0066ff';
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(350, 350, 5 / zoom, 0, Math.PI * 2); // Center of 700x700 canvas
            ctx.fill();
            ctx.restore();

            shapes.forEach(shape => shape.draw(ctx, false, zoom));
            walls.forEach(wall => wall.draw(ctx, false, zoom));
            windows.forEach(window => window.draw(ctx, false, zoom));
            reinforcedWalls.forEach(wall => wall.draw(ctx, false, zoom));
            garageDoors.forEach(door => door.draw(ctx, false, zoom));
            securityGates.forEach(gate => gate.draw(ctx, false, zoom));
            turrets.forEach(turret => {
                // Removed green rings - they were confusing

                turret.draw(ctx, zoom);

                // Draw turret number above the turret
                if (turret.number) {
                    ctx.save();
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3 / zoom;
                    ctx.font = `bold ${20 / zoom}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';

                    const numberText = turret.number.toString();
                    const textX = turret.x;
                    const textY = turret.y - 18 / zoom; // Position above turret

                    // Draw black outline for visibility
                    ctx.strokeText(numberText, textX, textY);
                    // Draw white text on top
                    ctx.fillText(numberText, textX, textY);
                    ctx.restore();
                }

                // Removed all pulsating ring overlays - they were confusing
            });

            if (showAllTurrets) {
                turrets.forEach(turret => {
                    // In tactical mode, only show FOV for powered turrets (keep power requirement for "show all")
                    if (!tacticalModeActive || isTurretPowered(turret.number)) {
                        drawLineOfSight(ctx, turret, zoom, true);
                    }
                });
            } else if (tacticalModeActive) {
                // In tactical mode, show FOV for all powered turrets automatically
                turrets.forEach(turret => {
                    if (isTurretPowered(turret.number)) {
                        drawLineOfSight(ctx, turret, zoom, false);
                    }
                });
            } else if (showLineOfSight && lineOfSightTurret) {
                // Only show FOV if the turret is on the main canvas (floor 1) or doesn't have a floor number
                if (!lineOfSightTurret.floorNumber || lineOfSightTurret.floorNumber === 1) {
                    drawLineOfSight(ctx, lineOfSightTurret, zoom, false);
                }
            }

            // Draw snap indicators
            if (currentTool && currentTool !== 'wall' && currentTool !== 'window' && currentTool !== 'reinforcedWall' && currentTool !== 'door' && currentTool !== 'securityGate' && shapes.length > 0) {
                ctx.fillStyle = '#3498db';
                ctx.globalAlpha = 0.3;

                shapes.forEach(shape => {
                    const edges = shape.getEdges();
                    edges.forEach(edge => {
                        const midX = (edge.start.x + edge.end.x) / 2;
                        const midY = (edge.start.y + edge.end.y) / 2;

                        ctx.beginPath();
                        ctx.arc(midX, midY, 4 / zoom, 0, Math.PI * 2);
                        ctx.fill();
                    });
                });

                ctx.globalAlpha = 1;
            }

            if (snapEdge && ghostShape) {
                ctx.strokeStyle = '#2ecc71';
                ctx.lineWidth = 4 / zoom;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(snapEdge.start.x, snapEdge.start.y);
                ctx.lineTo(snapEdge.end.x, snapEdge.end.y);
                ctx.stroke();
            }

            if (ghostShape && currentTool && currentTool !== 'wall' && currentTool !== 'window' && currentTool !== 'reinforcedWall' && currentTool !== 'door' && currentTool !== 'securityGate') {
                const wouldOverlap = shapes.length > 0 && !snapEdge && checkOverlap(ghostShape, shapes);
                if (wouldOverlap) {
                    ctx.save();
                    ctx.translate(ghostShape.x, ghostShape.y);
                    ctx.rotate(ghostShape.rotation);

                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 3 / zoom;
                    ctx.beginPath();
                    ctx.moveTo(-20, -20);
                    ctx.lineTo(20, 20);
                    ctx.moveTo(20, -20);
                    ctx.lineTo(-20, 20);
                    ctx.stroke();

                    ctx.restore();
                } else {
                    ghostShape.draw(ctx, true, zoom);
                }
            }

            if (ghostWall && currentTool === 'wall') {
                ghostWall.draw(ctx, true, zoom);
            }
            if (ghostWindow && currentTool === "window") {
                ghostWindow.draw(ctx, true, zoom);
            }

            if (ghostReinforcedWall && currentTool === 'reinforcedWall') {
                ghostReinforcedWall.draw(ctx, true, zoom);
            }

            if (ghostGarageDoor && currentTool === 'door') {
                ghostGarageDoor.draw(ctx, true, zoom);
            }

            if (ghostSecurityGate && currentTool === 'securityGate') {
                ghostSecurityGate.draw(ctx, true, zoom);
            }

            ctx.restore();
        }

        // Canvas events
        // Add mouse leave event to clear ghost previews
        canvas.addEventListener('mouseleave', () => {
            ghostShape = null;
            ghostWall = null;
            ghostWindow = null;
            ghostReinforcedWall = null;
            ghostGarageDoor = null;
            ghostSecurityGate = null;
            draw();
        });

        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('click', handleMouseClick);
        canvas.addEventListener('contextmenu', handleRightClick);
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);

        // Fix for Replit preview window - ensure keyboard events work in iframe
        document.body.setAttribute("tabindex", "0");
        document.body.focus();

        // Ensure focus is maintained when clicking on canvas areas, but not form controls
        document.addEventListener("click", (e) => {
            // Don't steal focus from form controls like select dropdowns, inputs, buttons
            const formControls = ['SELECT', 'INPUT', 'BUTTON', 'TEXTAREA', 'OPTION'];
            if (!formControls.includes(e.target.tagName)) {
                document.body.focus();
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            if (isPanning) {
                const rect = canvas.getBoundingClientRect();
                lastMouseX = e.clientX - rect.left;
                lastMouseY = e.clientY - rect.top;
                canvas.style.cursor = 'grabbing';
            } else if (!currentTool) {
                const coords = getWorldCoords(e);

                for (let i = turrets.length - 1; i >= 0; i--) {
                    if (turrets[i].contains(coords.x, coords.y)) {
                        draggedTurret = turrets[i];

                        // Clear selections only on main canvas before selecting dragged turret
                        [...shapes, ...turrets, ...walls, ...windows, ...reinforcedWalls, ...garageDoors, ...securityGates].forEach(item => item.selected = false);
                        clearAllSelectionVariables();

                        draggedTurret.selected = true;
                        selectedTurret = draggedTurret;
                        updateSelectedInfo();
                        canvas.style.cursor = 'grabbing';
                        break;
                    }
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (draggedTurret) {
                draggedTurret = null;
                canvas.style.cursor = 'default';
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const worldX = (mouseX - panX) / zoom;
            const worldY = (mouseY - panY) / zoom;

            const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
            zoom = Math.max(0.2, Math.min(5, zoom * zoomDelta));

            panX = mouseX - worldX * zoom;
            panY = mouseY - worldY * zoom;

            draw();
        });

        // Zoom controls


        // Drag and drop functionality
        let draggedElement = null;

        document.querySelectorAll('.icon-item').forEach(item => {
            item.addEventListener('dragstart', (e) => {
                draggedElement = e.target.closest('.icon-item');
                draggedIcon = draggedElement.dataset.type;

                e.dataTransfer.effectAllowed = 'copy';
                e.dataTransfer.setData('text/plain', draggedIcon);

                draggedElement.classList.add('dragging');
            });

            item.addEventListener('dragend', (e) => {
                if (draggedElement) {
                    draggedElement.classList.remove('dragging');
                }
                draggedElement = null;
                draggedIcon = null;
                draw();
            });
        });

        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        canvas.addEventListener('drop', (e) => {
            e.preventDefault();

            if (draggedIcon === 'turret') {
                const coords = getWorldCoords(e);

                const newTurret = new Turret(coords.x, coords.y);
                newTurret.number = getNextTurretNumber();
                turrets.push(newTurret);
                updateFloorIndicator(floorManager.currentActiveFloor);

                deselectAll();
                newTurret.selected = true;
                selectedTurret = newTurret;

                if (!showAllTurrets) {
                    showLineOfSight = true;
                    lineOfSightTurret = newTurret;
                }

                updateSelectedInfo();
                draw();
            }
        });

        canvas.addEventListener('dragleave', (e) => {
            draw();
        });

        // Toggle all turrets button
        toggleAllBtn.addEventListener('click', () => {
            showAllTurrets = !showAllTurrets;

            if (showAllTurrets) {
                toggleAllBtn.textContent = 'Hide All Turret Views';
                toggleAllBtn.style.background = '#27ae60';
                showLineOfSight = false;
                lineOfSightTurret = null;
            } else {
                toggleAllBtn.textContent = 'Show All Turret Views';
                toggleAllBtn.style.background = '#e74c3c';
            }

            updateSelectedInfo();
            draw();
        });

        // Erase All button
        const eraseAllBtn = document.getElementById("eraseAllBtn");
        eraseAllBtn.addEventListener("click", () => {
            const confirmMessage = "Are you sure you want to erase all? It will not be saved.";
            if (confirm(confirmMessage)) {
                // Clear all arrays
                shapes = [];
                turrets = [];
                updateFloorIndicator(floorManager.currentActiveFloor);
                walls = [];
                windows = [];
                reinforcedWalls = [];
                garageDoors = [];
                securityGates = [];

                // Clear all additional floor data
                Object.keys(floorManager.floorData).forEach(floorKey => {
                    if (floorKey !== '1') { // Don't clear main floor data structure, just content
                        floorManager.floorData[floorKey] = floorManager.createEmptyFloorData();
                    }
                });

                // Clear power containers
                turretManager.powerContainers.length = 0;
                turretManager.selectedContainer = null;

                // Clear selection state
                selectedShape = null;
                selectedTurret = null;
                selectedWall = null;
                selectedWindow = null;
                selectedReinforcedWall = null;
                selectedGarageDoor = null;
                selectedSecurityGate = null;

                // Clear ghost previews
                ghostShape = null;
                ghostWall = null;
                ghostWindow = null;
                ghostReinforcedWall = null;
                ghostGarageDoor = null;
                ghostSecurityGate = null;

                // Reset line of sight display
                showLineOfSight = false;
                lineOfSightTurret = null;
                showAllTurrets = false;

                // Reset toggle button appearance
                elements.toggleAllBtn.textContent = "Show All Turret Views";
                elements.toggleAllBtn.style.background = "#e74c3c";

                // Update global turret numbering (should be empty now)
                updateAllTurretNumbers();

                // Redraw all floor canvases to clear them
                if (document.getElementById('floor2Canvas')) {
                    redrawFloorCanvasContent('floor2Canvas', 2);
                }
                if (document.getElementById('floor3Canvas')) {
                    redrawFloorCanvasContent('floor3Canvas', 3);
                }
                if (document.getElementById('floor4Canvas')) {
                    redrawFloorCanvasContent('floor4Canvas', 4);
                }
                if (document.getElementById('floor5Canvas')) {
                    redrawFloorCanvasContent('floor5Canvas', 5);
                }

                // Clear power container UI
                renderContainerList();

                // Update UI and redraw main canvas
                updateSelectedInfo();
                draw();
            }
        });

        // Save Map functionality
        const saveMapBtn = document.getElementById("saveMapBtn");
        saveMapBtn.addEventListener("click", async () => {
            const mapName = prompt("Enter a name for your map:");
            if (!mapName || mapName.trim() === '') {
                return;
            }

            const mapData = {
                shapes: shapes.map(shape => ({
                    type: shape.constructor.name,
                    x: shape.x,
                    y: shape.y,
                    rotation: shape.rotation,
                    blocking: shape.blocking || false
                })),
                turrets: turrets.map(turret => ({
                    x: turret.x,
                    y: turret.y,
                    rotation: turret.rotation,
                    number: turret.number
                })),
                walls: walls.map(wall => ({
                    x1: wall.x1,
                    y1: wall.y1,
                    x2: wall.x2,
                    y2: wall.y2
                })),
                windows: windows.map(window => ({
                    x1: window.x1,
                    y1: window.y1,
                    x2: window.x2,
                    y2: window.y2
                })),
                reinforcedWalls: reinforcedWalls.map(wall => ({
                    x1: wall.x1,
                    y1: wall.y1,
                    x2: wall.x2,
                    y2: wall.y2
                })),
                garageDoors: garageDoors.map(door => ({
                    x1: door.x1,
                    y1: door.y1,
                    x2: door.x2,
                    y2: door.y2,
                    isOpen: door.isOpen
                })),
                securityGates: securityGates.map(gate => ({
                    x1: gate.x1,
                    y1: gate.y1,
                    x2: gate.x2,
                    y2: gate.y2
                })),
                floorData: floorData,
                powerContainers: powerContainers || [],
                globalTurretCounter: globalTurretCounter
            };

            try {
                const response = await fetch('/api/maps', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name: mapName.trim(),
                        mapData: mapData
                    })
                });

                const result = await response.json();

                if (result.success) {
                    alert(`Map "${mapName}" saved successfully to database!`);
                } else {
                    alert('Error saving map: ' + result.error);
                }
            } catch (error) {
                console.error('Error saving map:', error);
                alert('Error saving map to database. Please try again.');
            }
        });

        // Load Map functionality
        const loadMapBtn = document.getElementById("loadMapBtn");
        loadMapBtn.addEventListener("click", async () => {
            try {
                const response = await fetch('/api/maps');
                const result = await response.json();

                if (!result.success || result.maps.length === 0) {
                    alert('No saved maps found in database.');
                    return;
                }

                // Create a simple map selection dialog
                let mapOptions = 'Select a map to load:\n\n';
                result.maps.forEach((map, index) => {
                    mapOptions += `${index + 1}. ${map.name} (Created: ${new Date(map.created_at).toLocaleDateString()})\n`;
                });

                const selection = prompt(mapOptions + '\nEnter the number of the map you want to load:');
                if (!selection) return;

                const mapIndex = parseInt(selection) - 1;
                if (mapIndex < 0 || mapIndex >= result.maps.length) {
                    alert('Invalid selection.');
                    return;
                }

                const selectedMap = result.maps[mapIndex];

                // Load the specific map data
                const mapResponse = await fetch(`/api/maps/${selectedMap.id}`);
                const mapResult = await mapResponse.json();

                if (!mapResult.success) {
                    alert('Error loading map data.');
                    return;
                }

                const mapData = mapResult.map.map_data;

                // Clear existing data
                shapes.length = 0;
                turrets.length = 0;
                walls.length = 0;
                windows.length = 0;
                reinforcedWalls.length = 0;
                garageDoors.length = 0;
                securityGates.length = 0;

                // Load shapes
                if (mapData.shapes) {
                    mapData.shapes.forEach(shapeData => {
                        let shape;
                        if (shapeData.type === 'Square') {
                            shape = new Square(shapeData.x, shapeData.y);
                        } else if (shapeData.type === 'Triangle') {
                            shape = new Triangle(shapeData.x, shapeData.y);
                        }
                        if (shape) {
                            shape.rotation = shapeData.rotation || 0;
                            shape.blocking = shapeData.blocking || false;
                            shapes.push(shape);
                        }
                    });
                }

                // Load turrets
                if (mapData.turrets) {
                    mapData.turrets.forEach(turretData => {
                        const turret = new Turret(turretData.x, turretData.y);
                        turret.rotation = turretData.rotation || 0;
                        turret.number = turretData.number;
                        turrets.push(turret);
                    });
                }

                // Load walls
                if (mapData.walls) {
                    mapData.walls.forEach(wallData => {
                        const wall = new Wall(wallData.x1, wallData.y1, wallData.x2, wallData.y2);
                        walls.push(wall);
                    });
                }

                // Load windows
                if (mapData.windows) {
                    mapData.windows.forEach(windowData => {
                        const window = new Window(windowData.x1, windowData.y1, windowData.x2, windowData.y2);
                        windows.push(window);
                    });
                }

                // Load reinforced walls
                if (mapData.reinforcedWalls) {
                    mapData.reinforcedWalls.forEach(wallData => {
                        const wall = new ReinforcedWall(wallData.x1, wallData.y1, wallData.x2, wallData.y2);
                        reinforcedWalls.push(wall);
                    });
                }

                // Load garage doors
                if (mapData.garageDoors) {
                    mapData.garageDoors.forEach(doorData => {
                        const door = new GarageDoor(doorData.x1, doorData.y1, doorData.x2, doorData.y2);
                        door.isOpen = doorData.isOpen || false;
                        garageDoors.push(door);
                    });
                }

                // Load security gates
                if (mapData.securityGates) {
                    mapData.securityGates.forEach(gateData => {
                        const gate = new SecurityGate(gateData.x1, gateData.y1, gateData.x2, gateData.y2);
                        securityGates.push(gate);
                    });
                }

                // Load floor data
                if (mapData.floorData) {
                    Object.assign(floorData, mapData.floorData);
                }

                // Load power containers
                if (mapData.powerContainers) {
                    turretManager.powerContainers = mapData.powerContainers;
                    renderContainerList();
                }

                // Load global turret counter
                if (mapData.globalTurretCounter) {
                    globalTurretCounter = mapData.globalTurretCounter;
                }

                // Redraw everything
                draw();
                updateAllTurretNumbers();

                // Redraw floor canvases
                if (document.getElementById('floor2Canvas')) {
                    redrawFloorCanvasContent('floor2Canvas', 2);
                }
                if (document.getElementById('floor3Canvas')) {
                    redrawFloorCanvasContent('floor3Canvas', 3);
                }
                if (document.getElementById('floor4Canvas')) {
                    redrawFloorCanvasContent('floor4Canvas', 4);
                }
                if (document.getElementById('floor5Canvas')) {
                    redrawFloorCanvasContent('floor5Canvas', 5);
                }

                alert(`Map "${selectedMap.name}" loaded successfully!`);

            } catch (error) {
                console.error('Error loading maps:', error);
                alert('Error loading maps from database. Please try again.');
            }
        });

        // Manage Map functionality
        const manageMapBtn = document.getElementById("manageMapBtn");
        manageMapBtn.addEventListener("click", async () => {
            try {
                const response = await fetch('/api/maps');
                const result = await response.json();

                if (!result.success || result.maps.length === 0) {
                    alert('No saved maps found in database.');
                    return;
                }

                // Create a map management dialog
                let mapOptions = 'Manage your saved maps:\n\n';
                result.maps.forEach((map, index) => {
                    mapOptions += `${index + 1}. ${map.name} (Created: ${new Date(map.created_at).toLocaleDateString()})\n`;
                });

                const action = prompt(mapOptions + '\nChoose an action:\n• Type the map number to DELETE it\n• Type "cancel" to exit\n\nEnter your choice:');
                if (!action || action.toLowerCase() === 'cancel') return;

                const mapIndex = parseInt(action) - 1;
                if (mapIndex < 0 || mapIndex >= result.maps.length) {
                    alert('Invalid selection.');
                    return;
                }

                const selectedMap = result.maps[mapIndex];

                // Confirm deletion
                const confirmDelete = confirm(`Are you sure you want to DELETE the map "${selectedMap.name}"?\n\nThis action cannot be undone!`);
                if (!confirmDelete) return;

                // Delete the map
                const deleteResponse = await fetch(`/api/maps/${selectedMap.id}`, {
                    method: 'DELETE'
                });

                const deleteResult = await deleteResponse.json();

                if (deleteResult.success) {
                    alert(`Map "${selectedMap.name}" has been deleted successfully.`);
                } else {
                    alert('Error deleting map: ' + deleteResult.error);
                }

            } catch (error) {
                console.error('Error managing maps:', error);
                alert('Error accessing map database. Please try again.');
            }
        });








        // Header selection buttons functionality
        const mapEditorBtn = document.getElementById("mapEditorBtn");
        const tacticalMapBtn = document.getElementById("tacticalMapBtn");

        function selectHeaderButton(selectedBtn, otherBtn) {
            // Style selected button
            selectedBtn.style.background = "#3498db";
            selectedBtn.style.color = "white";

            // Style unselected button
            otherBtn.style.background = "white";
            otherBtn.style.color = "#3498db";
        }

        mapEditorBtn.addEventListener("click", () => {
            selectHeaderButton(mapEditorBtn, tacticalMapBtn);
            showMapEditor();
        });

        tacticalMapBtn.addEventListener("click", () => {
            selectHeaderButton(tacticalMapBtn, mapEditorBtn);
            showTacticalMap();
        });

        // Floor select functionality
        const floorSelect = document.getElementById('floorSelect');
        floorSelect.addEventListener('change', (e) => {
            const selectedFloors = parseInt(e.target.value);
            // Update the floor display
            updateFloorDisplay(selectedFloors);
            // Redraw all relevant floor canvases
            updateAllFloorDisplays();
            // Update the floor indicator text
            updateFloorIndicator(floorManager.currentActiveFloor);
        });

        // Function to update floor display based on selected number of floors
        function updateFloorDisplay(floors) {
            const additionalFloorsContainer = document.getElementById('additionalFloors');
            const floors45Container = document.getElementById('floors45Container');

            if (!additionalFloorsContainer) {
                console.error("Additional floors container not found.");
                return;
            }

            // Hide all additional floors initially
            additionalFloorsContainer.style.display = 'none';
            if (floors45Container) floors45Container.style.display = 'none';

            // Show relevant floors based on selection
            if (floors > 1) {
                additionalFloorsContainer.style.display = 'flex';
                if (floors >= 5 && floors45Container) {
                    floors45Container.style.display = 'flex';
                }
            }

            floorManager.currentFloors = floors; // Update manager's floor count
            floorManager.currentActiveFloor = 1; // Reset to main floor

            // Re-initialize canvases if they haven't been initialized yet
            // This ensures correct event listeners and initial state
            const canvasesToInitialize = [
                { id: 'floor2Canvas', floorNum: 2 },
                { id: 'floor3Canvas', floorNum: 3 },
                { id: 'floor4Canvas', floorNum: 4 },
                { id: 'floor5Canvas', floorNum: 5 }
            ];

            canvasesToInitialize.forEach(({ id, floorNum }) => {
                if (floorNum <= floors) {
                    floorManager.initializeFloorCanvas(id, floorNum);
                }
            });

            // Make sure main canvas is always redrawn
            draw();
        }


        // Left-click drag panning (replaces spacebar panning)
        let leftMouseDown = false;
        let panningActive = false;

        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Left mouse button
                leftMouseDown = true;

                // Start panning if no tool is selected and not clicking on objects
                if (!currentTool) {
                    const coords = getWorldCoords(e);
                    let clickedObject = false;

                    // Check if clicking on any interactive object
                    for (const turret of turrets) {
                        if (turret.contains(coords.x, coords.y)) {
                            clickedObject = true;
                            break;
                        }
                    }

                    if (!clickedObject) {
                        panningActive = true;
                        isPanning = true;
                        const rect = canvas.getBoundingClientRect();
                        lastMouseX = e.clientX - rect.left;
                        lastMouseY = e.clientY - rect.top;
                        canvas.style.cursor = 'grabbing';
                        e.preventDefault();
                    }
                }
            }
        }, true);

        document.addEventListener('mouseup', (e) => {
            if (e.button === 0 && leftMouseDown) { // Left mouse button
                leftMouseDown = false;
                if (panningActive) {
                    panningActive = false;
                    isPanning = false;
                    canvas.style.cursor = currentTool ? 'crosshair' : 'default';
                }
            }
        });



        // Also override the mousedown to disable turret dragging
        // canvas.removeEventListener('mousedown', canvas.mousedownHandler); // Fixed - mousedownHandler doesn't exist
        canvas.addEventListener('mousedown', (e) => {
            if (isPanning) {
                const rect = canvas.getBoundingClientRect();
                lastMouseX = e.clientX - rect.left;
                lastMouseY = e.clientY - rect.top;
                canvas.style.cursor = 'grabbing';
            } else if (!currentTool) {
                const coords = getWorldCoords(e);

                // Select and enable dragging for turrets
                for (let i = turrets.length - 1; i >= 0; i--) {
                    if (turrets[i].contains(coords.x, coords.y)) {
                        deselectAll();
                        turrets[i].selected = true;
                        selectedTurret = turrets[i];
                        updateSelectedInfo();
                        // Enable dragging for turrets
                        draggedTurret = turrets[i];
                        break;
                    }
                }
            }
        });

        // Handle mouseup to stop turret dragging
        canvas.addEventListener('mouseup', (e) => {
            if (draggedTurret) {
                draggedTurret = null;
            }
            // No turret dragging to clean up
        });
        // External Wall placement function (no snapping)
        function placeExternalWall(x, y) {
            const newWall = new Square2(x, y);
            newWall.rotation = previewRotation; // Apply the preview rotation
            shapes.push(newWall);
            previewRotation = 0; // Reset after placement
            draw();
        }

        // Turret placement function for main canvas
        function placeTurret(x, y) {
            const gameState = { turrets, showAllTurrets, showLineOfSight, lineOfSightTurret };
            const callbacks = {
                deselectAll,
                updateSelectedInfo,
                updateFloorIndicator,
                draw
            };

            const newTurret = turretManager.placeTurret(x, y, gameState, callbacks);

            if (newTurret) {
                selectedTurret = newTurret;
                showLineOfSight = gameState.showLineOfSight;
                lineOfSightTurret = gameState.lineOfSightTurret;
            }
        }

        // Floor select functionality now handled by FloorManager
        // Access floor data via floorManager.floorData

        // Floor system initialization now handled by FloorManager
        function initializeFloorSystem() {
            const callbacks = {
                initializeFloorCanvas: initializeFloorCanvas
            };
            floorManager.initializeFloorSystem(elements, callbacks);
        }

        // Initialize immediately and also on DOMContentLoaded
        initializeFloorSystem();
        document.addEventListener('DOMContentLoaded', () => {
            initializeFloorSystem();
            updateFloorDisplay(5); // Initialize with 5 floors as default (use local function)
            updateFloorIndicator(1); // Initialize turret count display
            initializeGlobalTurretCounter(); // Initialize turret numbering system
        });

        // Initialize global turret counter based on existing turrets
        function initializeGlobalTurretCounter() {
            const gameState = { turrets };
            turretManager.initializeGlobalTurretCounter({ turrets: gameState.turrets }, floorManager.floorData);
        }

        // Floor display management (temporarily restored)
        function updateFloorDisplay(floors) {
            const additionalFloorsContainer = document.getElementById('additionalFloors');

            if (!additionalFloorsContainer) {
                console.error("Additional floors container not found");
                return;
            }

            if (floors === 1) {
                additionalFloorsContainer.style.display = 'none';
                const floors45Container = document.getElementById('floors45Container');
                if (floors45Container) {
                    floors45Container.style.display = 'none';
                }
            } else if (floors === 3) {
                additionalFloorsContainer.style.display = 'flex';
                const floors45Container = document.getElementById('floors45Container');
                if (floors45Container) {
                    floors45Container.style.display = 'none';
                }
                // Initialize floor 2 and 3 canvases
                setTimeout(() => {
                    initializeFloorCanvas('floor2Canvas', 2);
                    initializeFloorCanvas('floor3Canvas', 3);
                }, 100);
            } else if (floors === 5) {
                additionalFloorsContainer.style.display = 'flex';
                const floors45Container = document.getElementById('floors45Container');
                if (floors45Container) {
                    floors45Container.style.display = 'flex';
                }
                // Initialize all canvases for 5 floors
                setTimeout(() => {
                    initializeFloorCanvas('floor2Canvas', 2);
                    initializeFloorCanvas('floor3Canvas', 3);
                    initializeFloorCanvas('floor4Canvas', 4);
                    initializeFloorCanvas('floor5Canvas', 5);
                }, 100);
            }

            floorManager.currentFloors = floors;
        }

        // Floor canvas state now managed by FloorManager
        // Access via floorManager.floorCanvasStates

        // RESTORE ORIGINAL - Use FloorManager methods directly
        function initializeFloorCanvas(canvasId, floorNumber) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const state = floorManager.floorCanvasStates[canvasId];

            // Only initialize once
            if (state.initialized) {
                floorManager.redrawFloorCanvasContent(canvasId, floorNumber);
                return;
            }

            // Direct event listener setup using FloorManager handlers
            canvas.addEventListener('wheel', (e) => {
                floorManager.handleFloorCanvasZoom(e, canvas, canvasId, floorNumber);
            });

            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 1 || (e.ctrlKey && e.button === 0)) {
                    const state = floorManager.floorCanvasStates[canvasId];
                    if (state) {
                        state.isPanningFloor = true;
                        const rect = canvas.getBoundingClientRect();
                        state.lastFloorMouseX = e.clientX - rect.left;
                        state.lastFloorMouseY = e.clientY - rect.top;
                        canvas.style.cursor = 'grabbing';
                        e.preventDefault();
                    }
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                const state = floorManager.floorCanvasStates[canvasId];
                if (state && state.isPanningFloor) {
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    state.panX += mouseX - state.lastFloorMouseX;
                    state.panY += mouseY - state.lastFloorMouseY;
                    state.lastFloorMouseX = mouseX;
                    state.lastFloorMouseY = mouseY;
                    floorManager.redrawFloorCanvasContent(canvasId, floorNumber);
                }
            });

            canvas.addEventListener('mouseup', () => {
                const state = floorManager.floorCanvasStates[canvasId];
                if (state) {
                    state.isPanningFloor = false;
                }
                canvas.style.cursor = currentTool ? 'crosshair' : 'grab';
            });

            canvas.addEventListener('mouseleave', () => {
                const state = floorManager.floorCanvasStates[canvasId];
                if (state) {
                    state.isPanningFloor = false;
                }
                canvas.style.cursor = currentTool ? 'crosshair' : 'grab';
            });

            canvas.addEventListener('click', (e) => {
                floorManager.handleFloorCanvasClick(e, canvasId, floorNumber);
            });

            canvas.addEventListener('drop', (e) => {
                floorManager.handleFloorCanvasDrop(e, canvasId, floorNumber);
            });

            canvas.addEventListener('dragover', (e) => {
                e.preventDefault();
            });

            // Mark as initialized and draw
            floorManager.initializeFloorCanvas(canvasId, floorNumber);
        }

        // Update all floor canvas cursors (temporarily restored)
        window.updateAllFloorCanvasCursors = function() {
            const cursor = currentTool ? 'crosshair' : 'grab';

            // Update additional floor canvases
            const floor2Canvas = document.getElementById('floor2Canvas');
            const floor3Canvas = document.getElementById('floor3Canvas');
            const floor4Canvas = document.getElementById('floor4Canvas');
            const floor5Canvas = document.getElementById('floor5Canvas');
            if (floor2Canvas) floor2Canvas.style.cursor = cursor;
            if (floor3Canvas) floor3Canvas.style.cursor = cursor;
            if (floor4Canvas) floor4Canvas.style.cursor = cursor;
            if (floor5Canvas) floor5Canvas.style.cursor = cursor;
        }


        // Handle clicks on additional floor canvases for selection
        function handleFloorTurretClick(turret, floorNumber) {
            // Ensure the turret has the correct floorNumber property
            turret.floorNumber = floorNumber;

            if (showAllTurrets) {
                // In show all mode, just select the turret
                deselectAll();
                turret.selected = true;
                selectedTurret = turret;
            } else {
                // Toggle line of sight for this turret
                if (turret === selectedTurret && lineOfSightTurret === selectedTurret && showLineOfSight) {
                    showLineOfSight = false;
                    lineOfSightTurret = null;
                } else {
                    deselectAll();
                    turret.selected = true;
                    selectedTurret = turret;
                    showLineOfSight = true;
                    lineOfSightTurret = turret;
                }
            }

            updateSelectedInfo();

            // Redraw all floor canvases to update FOV display
            redrawAllFloorCanvases();

            // Also redraw main canvas in case it needs updates
            draw();
        }

        // Legacy function - now using redrawFloorCanvasContent

        // Draw grid for smaller floor canvases with proper zoom scaling
        function drawFloorGrid(ctx, canvasId) {
            const state = floorManager.floorCanvasStates[canvasId];
            const canvas = document.getElementById(canvasId);

            ctx.strokeStyle = tacticalModeActive ? '#555555' : '#ddd';
            ctx.lineWidth = 0.5 / state.zoom;

            // Use the same meter-based grid as main canvas
            const gridSpacing = PIXELS_PER_METER; // 40 pixels per meter

            // Calculate visible grid range
            const startX = Math.floor((-state.panX / state.zoom) / gridSpacing) * gridSpacing;
            const endX = Math.ceil((canvas.width - state.panX) / state.zoom / gridSpacing) * gridSpacing;
            const startY = Math.floor((-state.panY / state.zoom) / gridSpacing) * gridSpacing;
            const endY = Math.ceil((canvas.height - state.panY) / state.zoom / gridSpacing) * gridSpacing;

            // Draw vertical grid lines
            for (let x = startX; x <= endX; x += gridSpacing) {
                ctx.beginPath();
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
                ctx.stroke();
            }

            // Draw horizontal grid lines
            for (let y = startY; y <= endY; y += gridSpacing) {
                ctx.beginPath();
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
                ctx.stroke();
            }
        }

        // Draw floor content - each floor has its own coordinate system
        function drawFloorContent(ctx, floorNumber, zoom) {
            const floor = floorManager.floorData[floorNumber];
            if (!floor) return;

            // Draw the floor content with proper zoom parameter (no additional scaling)
            // Draw shapes
            floor.shapes.forEach(shape => {
                if (shape.draw) {
                    shape.draw(ctx, false, zoom);
                }
            });

            // Draw walls
            floor.walls.forEach(wall => {
                if (wall.draw) {
                    wall.draw(ctx, false, zoom);
                }
            });

            // Draw windows
            floor.windows.forEach(window => {
                if (window.draw) {
                    window.draw(ctx, false, zoom);
                }
            });

            // Draw reinforced walls (door frames)
            if (floor.reinforcedWalls) {
                floor.reinforcedWalls.forEach(wall => {
                    if (wall.draw) {
                        wall.draw(ctx, false, zoom);
                    }
                });
            }

            // Draw garage doors
            if (floor.garageDoors) {
                floor.garageDoors.forEach(door => {
                    if (door.draw) {
                        door.draw(ctx, false, zoom);
                    }
                });
            }

            // Draw security gates
            if (floor.securityGates) {
                floor.securityGates.forEach(gate => {
                    if (gate.draw) {
                        gate.draw(ctx, false, zoom);
                    }
                });
            }

            // Draw turrets
            floor.turrets.forEach(turret => {
                // Removed green rings - they were confusing

                if (turret.draw) {
                    turret.draw(ctx, zoom);
                }

                // Draw turret number above the turret
                if (turret.number) {
                    ctx.save();
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3 / zoom;
                    ctx.font = `bold ${20 / zoom}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';

                    const numberText = turret.number.toString();
                    const textX = turret.x;
                    const textY = turret.y - 18 / zoom; // Position above turret

                    // Draw black outline for visibility
                    ctx.strokeText(numberText, textX, textY);
                    // Draw white text on top
                    ctx.fillText(numberText, textX, textY);
                    ctx.restore();
                }

                // Removed all pulsating ring overlays - they were confusing
            });

            // Draw line of sight for turrets on this floor (optimized)
            if (showAllTurrets && floor.turrets.length > 0) {
                floor.turrets.forEach(turret => {
                    // In tactical mode, only show FOV for powered turrets
                    if (!tacticalModeActive || isTurretPowered(turret.number)) {
                        drawLineOfSightForFloor(ctx, turret, zoom, floor);
                    }
                });
            } else if (tacticalModeActive && floor.turrets.length > 0) {
                // In tactical mode, show FOV for all powered turrets on this floor automatically
                floor.turrets.forEach(turret => {
                    if (isTurretPowered(turret.number)) {
                        drawLineOfSightForFloor(ctx, turret, zoom, floor);
                    }
                });
            } else if (showLineOfSight && lineOfSightTurret && floor.turrets.includes(lineOfSightTurret)) {
                // Only draw FOV if turret is actually on this floor
                drawLineOfSightForFloor(ctx, lineOfSightTurret, zoom, floor);
            }
        }

        // Switch to specific floor (only used for main canvas via dropdown)
        function switchToFloor(floorNumber) {
            if (floorNumber === floorManager.currentActiveFloor) return;

            // Save current floor data
            saveCurrentFloorData();

            // Load new floor data
            loadFloorData(floorNumber);

            floorManager.currentActiveFloor = floorNumber;

            // Update floor indicator
            updateFloorIndicator(floorNumber);

            // Redraw main canvas only (additional floors stay independent)
            draw();

        }

        // Save current floor data to storage
        function saveCurrentFloorData() {
            floorManager.floorData[floorManager.currentActiveFloor] = {
                shapes: [...shapes],
                turrets: [...turrets],
                walls: [...walls],
                windows: [...windows],
                reinforcedWalls: [...reinforcedWalls],
                garageDoors: [...garageDoors],
                securityGates: [...securityGates]
            };
        }

        // Load floor data from storage
        function loadFloorData(floorNumber) {
            const floor = floorManager.floorData[floorNumber];

            shapes = [...floor.shapes];
            turrets = [...floor.turrets];
            walls = [...floor.walls];
            windows = [...floor.windows];
            reinforcedWalls = [...floor.reinforcedWalls];
            garageDoors = [...floor.garageDoors];
            securityGates = [...floor.securityGates];

            // Update turret count display
            updateFloorIndicator(floorNumber);
        }

        // Count all connected turrets (not just powered ones within limit)
        function countConnectedTurrets() {
            let connectedCount = 0;

            // Count connected turrets on main canvas
            turrets.forEach(turret => {
                if (isConnectedToEnabledContainer(turret.number)) {
                    connectedCount++;
                }
            });

            // Count connected turrets on all additional floors
            for (let floorNum = 2; floorNum <= 5; floorNum++) {
                if (floorManager.floorData[floorNum] && floorManager.floorData[floorNum].turrets) {
                    floorManager.floorData[floorNum].turrets.forEach(turret => {
                        if (isConnectedToEnabledContainer(turret.number)) {
                            connectedCount++;
                        }
                    });
                }
            }

            return connectedCount;
        }

        // Check if turret is connected to an enabled container (regardless of power limit)
        function isConnectedToEnabledContainer(turretNumber) {
            if (!tacticalModeActive) return false;
            return turretManager.powerContainers.some(container =>
                container.enabled && container.connectedTurrets.includes(turretNumber)
            );
        }

        // Update floor indicator - shows connected turrets vs capacity (can exceed 12)
        function updateFloorIndicator(floorNumber) {
            const indicator = document.getElementById('currentFloorIndicator');
            if (indicator) {
                const connectedCount = countConnectedTurrets();
                indicator.textContent = `${connectedCount}/12`;

                // Add pulsating/glowing effect if connected turrets exceed 12
                if (connectedCount > 12) {
                    indicator.className = 'floor-indicator-btn turret-count-btn turret-overload';
                } else {
                    indicator.className = 'floor-indicator-btn turret-count-btn';
                }
            }
        }

        // Floor-specific snapping functions
        function findSnapPositionOnFloor(shape, floorShapes) {
            return findSnapPosition(shape, floorShapes);
        }

        function findNearestEdgeOnFloor(mousePos, floorShapes) {
            return findNearestEdge(mousePos, floorShapes);
        }

        // Draw ghost previews for floor canvases
        function drawFloorGhosts(ctx, canvasId, scale) {
            const canvas = document.getElementById(canvasId);
            if (!canvas.floorGhosts) return;

            const state = floorManager.floorCanvasStates[canvasId];
            const ghosts = canvas.floorGhosts;

            if (ghosts.floorGhostShape) {
                ghosts.floorGhostShape.draw(ctx, true, state.zoom);
            }

            if (ghosts.floorGhostWall) {
                ghosts.floorGhostWall.draw(ctx, true, state.zoom);
            }

            if (ghosts.floorGhostWindow) {
                ghosts.floorGhostWindow.draw(ctx, true, state.zoom);
            }

            if (ghosts.floorGhostReinforcedWall) {
                ghosts.floorGhostReinforcedWall.draw(ctx, true, state.zoom);
            }

            if (ghosts.floorGhostGarageDoor) {
                ghosts.floorGhostGarageDoor.draw(ctx, true, state.zoom);
            }

            if (ghosts.floorGhostSecurityGate) {
                ghosts.floorGhostSecurityGate.draw(ctx, true, state.zoom);
            }

            if (ghosts.floorGhostTurret) {
                ghosts.floorGhostTurret.draw(ctx, state.zoom);
            }
        }

        // Place edge item directly on specified floor
        function placeEdgeItemDirectlyOnFloor(edge, floorNumber, itemType) {
            const floor = floorManager.floorData[floorNumber];

            if (itemType === 'wall') {
                const wall = new Wall(edge);
                floor.walls.push(wall);
            } else if (itemType === 'window') {
                const window = new WindowTool(edge);
                floor.windows.push(window);
            } else if (itemType === 'reinforcedWall') {
                if (!floor.reinforcedWalls) floor.reinforcedWalls = [];
                const reinforcedWall = new ReinforcedWall(edge);
                floor.reinforcedWalls.push(reinforcedWall);
            } else if (itemType === 'door') {
                if (!floor.garageDoors) floor.garageDoors = [];
                const garageDoor = new GarageDoor(edge, false);
                floor.garageDoors.push(garageDoor);
            } else if (itemType === 'securityGate') {
                if (!floor.securityGates) floor.securityGates = [];
                const securityGate = new SecurityGate(edge);
                floor.securityGates.push(securityGate);
            }

            // Redraw all floor canvases that are currently visible
            redrawAllFloorCanvases();
        }

        // Place turret directly on specified floor
        function placeTurretDirectlyOnFloor(x, y, floorNumber) {
            const gameState = { showLineOfSight, lineOfSightTurret };
            const callbacks = {
                deselectAll,
                updateSelectedInfo,
                redrawAllFloorCanvases,
                draw
            };

            const newTurret = turretManager.placeTurretOnFloor(x, y, floorNumber, floorManager.floorData, gameState, callbacks);

            if (newTurret) {
                selectedTurret = newTurret;
                showLineOfSight = gameState.showLineOfSight;
                lineOfSightTurret = gameState.lineOfSightTurret;
            }
        }

        // Global turret counter now managed by TurretManager
        function getNextTurretNumber() {
            return turretManager.getNextTurretNumber();
        }

        // Update turret numbers globally across all floors (only use when needed for deletion cleanup)
        function updateAllTurretNumbers() {
            const gameState = { turrets };
            turretManager.updateAllTurretNumbers({ turrets: gameState.turrets }, floorManager.floorData);
        }

        // Update turret numbers for a specific floor (now calls global update)
        function updateTurretNumbers(floorNumber) {
            updateAllTurretNumbers();
        }

        // Update turret numbers for main canvas (now calls global update)
        function updateMainCanvasTurretNumbers() {
            updateAllTurretNumbers();
        }

        // Draw line of sight for turrets on specific floors - rebuilt to match main canvas RED FOV
        function drawLineOfSightForFloor(ctx, turret, currentZoom, floor) {
            if (!turret || !floor) return;


            const turretPos = { x: turret.x, y: turret.y };
            const viewRadius = 30 * PIXELS_PER_METER; // 30 meter range
            const numRays = 180; // More rays for smoother FOV

            // Calculate turret facing direction (rotation - 90 degrees)
            const facingAngle = turret.rotation - Math.PI / 2;
            const fovAngle = Math.PI; // 180 degree FOV cone
            const startAngle = facingAngle - fovAngle / 2;
            const endAngle = facingAngle + fovAngle / 2;

            // Get all blocking edges from shapes and walls on this floor
            const blockingEdges = [];

            // Add shape edges
            floor.shapes.forEach(shape => {
                if (!shape.transparent && shape.getEdges) {
                    const edges = shape.getEdges();
                    edges.forEach(edge => blockingEdges.push(edge));
                }
            });

            // Add wall edges
            floor.walls.forEach(wall => {
                if (!wall.transparent) {
                    blockingEdges.push(wall.edge);
                }
            });

            // Add window edges (they block vision)
            floor.windows.forEach(window => {
                if (!window.transparent) {
                    blockingEdges.push(window.edge);
                }
            });

            // Add reinforced wall edges (handle open/closed state)
            if (floor.reinforcedWalls) {
                floor.reinforcedWalls.forEach(wall => {
                    if (!wall.isOpen) { // If closed, block entire edge
                        blockingEdges.push(wall.edge);
                    } else { // If open, block segments
                        const gap = wall.getGapBounds();
                        blockingEdges.push({ start: wall.edge.start, end: gap.start });
                        blockingEdges.push({ start: gap.end, end: wall.edge.end });
                    }
                });
            }

            // Add garage door edges (always block if present)
            if (floor.garageDoors) {
                floor.garageDoors.forEach(door => {
                    if (!door.isOpen) { // Only block if closed
                        blockingEdges.push(door.edge);
                    }
                });
            }

            // Cast rays and find visibility boundary
            const visibilityPoints = [];

            for (let i = 0; i <= numRays; i++) {
                const rayAngle = startAngle + (endAngle - startAngle) * (i / numRays);
                const rayEnd = {
                    x: turretPos.x + Math.cos(rayAngle) * viewRadius,
                    y: turretPos.y + Math.sin(rayAngle) * viewRadius
                };

                let closestDistance = viewRadius;
                let closestPoint = rayEnd;

                // Check intersections with all blocking edges
                for (const edge of blockingEdges) {
                    const intersection = lineIntersection(
                        turretPos, rayEnd,
                        edge.start, edge.end
                    );

                    if (intersection) {
                        const distance = Math.sqrt(
                            Math.pow(intersection.x - turretPos.x, 2) +
                            Math.pow(intersection.y - turretPos.y, 2)
                        );

                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestPoint = intersection;
                        }
                    }
                }

                visibilityPoints.push(closestPoint);
            }

            // Draw the FOV cone with proper RED color
            if (visibilityPoints.length > 0) {
                ctx.save();

                // Create gradient for realistic FOV appearance
                const gradient = ctx.createRadialGradient(
                    turretPos.x, turretPos.y, 0,
                    turretPos.x, turretPos.y, viewRadius
                );
                gradient.addColorStop(0, 'rgba(255, 0, 0, 0.4)'); // Bright red at center
                gradient.addColorStop(1, 'rgba(255, 0, 0, 0.1)'); // Fading red at edges

                ctx.fillStyle = gradient;
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)'; // Red outline
                ctx.lineWidth = 2 / currentZoom;

                // Draw the FOV cone
                ctx.beginPath();
                ctx.moveTo(turretPos.x, turretPos.y);

                visibilityPoints.forEach(point => {
                    ctx.lineTo(point.x, point.y);
                });

                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.restore();

                console.log(`FOV cone drawn with ${visibilityPoints.length} visibility points`);
            }
        }

        // Collect blocking vertices for a specific floor - simplified for ray casting
        function collectBlockingVerticesForFloor(floor) {
            const vertices = [];

            // Add shape vertices
            floor.shapes.forEach(shape => {
                if (!shape.transparent && shape.getEdges) {
                    const edges = shape.getEdges();
                    edges.forEach(edge => {
                        vertices.push(edge.start);
                        vertices.push(edge.end);
                    });
                }
            });

            // Add wall vertices
            floor.walls.forEach(wall => {
                if (!wall.transparent) {
                    vertices.push(wall.edge.start);
                    vertices.push(wall.edge.end);
                }
            });

            // Add window vertices
            floor.windows.forEach(window => {
                if (!window.transparent) {
                    vertices.push(window.edge.start);
                    vertices.push(window.edge.end);
                }
            });

            // Add other edge types if they exist
            if (floor.reinforcedWalls) {
                floor.reinforcedWalls.forEach(wall => {
                    if (!wall.transparent) {
                        vertices.push(wall.edge.start);
                        vertices.push(wall.edge.end);
                    }
                });
            }

            if (floor.garageDoors) {
                floor.garageDoors.forEach(door => {
                    if (!door.transparent) {
                        vertices.push(door.edge.start);
                        vertices.push(door.edge.end);
                    }
                });
            }

            if (floor.securityGates) {
                floor.securityGates.forEach(gate => {
                    if (!gate.transparent) {
                        vertices.push(gate.edge.start);
                        vertices.push(gate.edge.end);
                    }
                });
            }

            return vertices;
        }

        // Place shape directly on specific floor without affecting main canvas
        function placeShapeDirectlyOnFloor(worldX, worldY, floorNumber, rotation = 0) {

            // Get the target floor data
            const targetFloor = floorManager.floorData[floorNumber];
            let newShape = null;

            if (currentTool === 'square') {
                newShape = new Square(worldX, worldY);
                if (rotation) newShape.rotation = rotation;
                targetFloor.shapes.push(newShape);
            } else if (currentTool === 'triangle') {
                newShape = new Triangle(worldX, worldY);
                if (rotation) newShape.rotation = rotation;
                targetFloor.shapes.push(newShape);
            } else if (currentTool === 'square2') {
                newShape = new Square2(worldX, worldY);
                newShape.rotation = rotation || previewRotation || 0;
                targetFloor.shapes.push(newShape);
            } else if (currentTool === 'turret') {
                newShape = new Turret(worldX, worldY);
                targetFloor.turrets.push(newShape);
            }

            // Handle edge-based tools (walls, windows, etc.)
            if (currentTool === 'wall' || currentTool === 'window' || currentTool === 'reinforcedWall' || currentTool === 'door' || currentTool === 'securityGate') {
                if (targetFloor.shapes.length > 0) {
                    // Use shapes from target floor for edge detection
                    const nearestEdge = findNearestEdgeInShapes(worldX, worldY, targetFloor.shapes);
                    if (nearestEdge && !edgeExistsInFloor(nearestEdge, targetFloor)) {
                        if (currentTool === 'wall') {
                            targetFloor.walls.push(new Wall(nearestEdge));
                        } else if (currentTool === 'window') {
                            targetFloor.windows.push(new WindowTool(nearestEdge));
                        } else if (currentTool === 'reinforcedWall') {
                            if (!targetFloor.reinforcedWalls) targetFloor.reinforcedWalls = [];
                            targetFloor.reinforcedWalls.push(new ReinforcedWall(nearestEdge));
                        } else if (currentTool === 'door') {
                            if (!targetFloor.garageDoors) targetFloor.garageDoors = [];
                            targetFloor.garageDoors.push(new GarageDoor(nearestEdge, false));
                        } else if (currentTool === 'securityGate') {
                            if (!targetFloor.securityGates) targetFloor.securityGates = [];
                            targetFloor.securityGates.push(new SecurityGate(nearestEdge));
                        }
                    }
                }
            }

            // Update only the additional floor displays (don't affect main canvas)
            updateAllFloorDisplays();

            // Note: Tool remains selected for easier multiple placements
        }

        // Helper function to calculate distance from point to line
        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            if (lenSq !== 0) {
                param = dot / lenSq;
            }

            let xx, yy;
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Helper function to find nearest edge in specific shapes array
        function findNearestEdgeInShapes(x, y, shapesArray) {
            let nearestEdge = null;
            let minDistance = Infinity;

            for (const shape of shapesArray) {
                const edges = shape.getEdges();
                for (const edge of edges) {
                    const distance = pointToLineDistance(x, y, edge.start.x, edge.start.y, edge.end.x, edge.end.y);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestEdge = edge;
                    }
                }
            }

            return minDistance <= 20 ? nearestEdge : null;
        }

        // Helper function to check if edge exists in specific floor
        function edgeExistsInFloor(edge, floor) {
            const allEdgeItems = [
                ...floor.walls,
                ...floor.windows,
                ...(floor.reinforcedWalls || []),
                ...(floor.garageDoors || []),
                ...(floor.securityGates || [])
            ];

            return allEdgeItems.some(item => {
                if (!item.edge) return false;
                return edgesCoincide(item.edge, edge);
            });
        }

        // Handle clicks on additional floor canvases for selection
        function handleFloorCanvasClick(e, canvasId, floorNum) {
            const canvas = document.getElementById(canvasId);
            const rect = canvas.getBoundingClientRect();
            const state = floorManager.floorCanvasStates[canvasId];

            // Calculate click position in canvas coordinates
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;

            // Convert to world coordinates accounting for pan and zoom
            const worldX = (canvasX - state.panX) / state.zoom;
            const worldY = (canvasY - state.panY) / state.zoom;



            const floor = floorManager.floorData[floorNum];
            if (!floor) return;

            // Check if clicking on any turret first
            const clickedTurret = floor.turrets.find(turret => {
                const distance = Math.sqrt((turret.x - worldX) ** 2 + (turret.y - worldY) ** 2);
                console.log(`Checking turret ${turret.number || 'unnumbered'} at ${turret.x}, ${turret.y}, distance: ${distance}`);
                return distance <= 25; // 25px click radius for turrets
            });

            if (clickedTurret) {
                // Handle turret selection (existing logic)
                return;
            }

            // Clear all selections first
            clearAllSelections();

            // Check for shape selection
            const clickedShape = floor.shapes.find(shape => {
                if (shape.constructor.name === 'Square') {
                    // Square selection logic
                    const halfSize = 20; // Half size of square
                    return worldX >= (shape.x - halfSize) && worldX <= (shape.x + halfSize) &&
                           worldY >= (shape.y - halfSize) && worldY <= (shape.y + halfSize);
                } else if (shape.constructor.name === 'Triangle') {
                    // Triangle selection logic - simple distance check for now
                    const distance = Math.sqrt((shape.x - worldX) ** 2 + (shape.y - worldY) ** 2);
                    return distance <= 25; // 25px click radius for triangles
                }
                return false;
            });

            if (clickedShape) {
                // Select the shape
                clickedShape.selected = true;
                selectedShape = clickedShape;
                floorManager.selectedFloor = floorNum;



                // Update selection info and redraw
                updateSelectedInfo();
                redrawFloorCanvasContent(canvasId, floorNum);
                draw(); // Also redraw main canvas in case of cross-floor effects
                return;
            }

            // Check for wall/edge item selection
            const allEdgeItems = [
                ...floor.walls,
                ...floor.windows,
                ...(floor.reinforcedWalls || []),
                ...(floor.garageDoors || []),
                ...(floor.securityGates || [])
            ];

            const clickedEdgeItem = allEdgeItems.find(item => {
                if (!item.edge) return false;
                const distance = distancePointToLine(worldX, worldY, item.edge);
                return distance <= 10; // 10px tolerance for edge items
            });

            if (clickedEdgeItem) {
                // Select the edge item
                clickedEdgeItem.selected = true;
                floorManager.selectedFloor = floorNum;

                // Set appropriate selected variable based on type
                if (floor.walls.includes(clickedEdgeItem)) selectedWall = clickedEdgeItem;
                else if (floor.windows.includes(clickedEdgeItem)) selectedWindow = clickedEdgeItem;
                else if (floor.reinforcedWalls && floor.reinforcedWalls.includes(clickedEdgeItem)) selectedReinforcedWall = clickedEdgeItem;
                else if (floor.garageDoors && floor.garageDoors.includes(clickedEdgeItem)) selectedGarageDoor = clickedEdgeItem;
                else if (floor.securityGates && floor.securityGates.includes(clickedEdgeItem)) selectedSecurityGate = clickedEdgeItem;



                // Update selection info and redraw
                updateSelectedInfo();
                redrawFloorCanvasContent(canvasId, floorNum);
                draw();
                return;
            }

            // If no items selected, clear selections only on this floor
            clearFloorSelections(floor);
            // Also clear global selections if the previously selected item was on this floor
            clearGlobalSelectionsFromFloor(floor);

            // Redraw only this floor canvas
            redrawFloorCanvasContent(canvasId, floorNumber);
            draw(); // Also redraw main canvas in case it needs updating
            updateSelectedInfo();
        }

        // Helper function to calculate distance from point to line
        function distancePointToLine(px, py, edge) {
            const { start, end } = edge;
            const A = px - start.x;
            const B = py - start.y;
            const C = end.x - start.x;
            const D = end.y - start.y;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;

            if (lenSq !== 0) {
                param = dot / lenSq;
            }

            let xx, yy;

            if (param < 0) {
                xx = start.x;
                yy = start.y;
            } else if (param > 1) {
                xx = end.x;
                yy = end.y;
            } else {
                xx = start.x + param * C;
                yy = start.y + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Track which floor has selected items (now managed by FloorManager)
        // Access via floorManager.selectedFloor

        // Floor display updates (temporarily restored)
        function updateAllFloorDisplays() {
            if (floorManager.currentFloors >= 3) {
                // Only redraw content, don't re-initialize
                redrawFloorCanvasContent('floor2Canvas', 2);
                redrawFloorCanvasContent('floor3Canvas', 3);

                if (floorManager.currentFloors >= 5) {
                    redrawFloorCanvasContent('floor4Canvas', 4);
                    redrawFloorCanvasContent('floor5Canvas', 5);
                }
            }
        }

        // Floor canvas content rendering (temporarily restored for stability)
        function redrawFloorCanvasContent(canvasId, floorNumber) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.log(`Canvas ${canvasId} not found for redraw.`);
                return;
            }
            const ctx = canvas.getContext('2d');
            const state = floorManager.floorCanvasStates[canvasId];

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(state.panX, state.panY);
            ctx.scale(state.zoom, state.zoom);

            // Draw grid background with proper zoom scaling
            drawFloorGrid(ctx, canvasId);

            // Draw floor content - each floor is independent 350x349 pixel world
            drawFloorContent(ctx, floorNumber, state.zoom);

            // Draw ghost previews if canvas is being hovered
            drawFloorGhosts(ctx, canvasId, state.zoom);

            // Draw center dot for alignment verification (red dot at canvas center)
            ctx.save();
            ctx.fillStyle = '#ff0000';
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            // Center of 350x349 canvas
            ctx.arc(175, 174.5, 3 / state.zoom, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            ctx.restore();
        }

        // Initialize
        generateTurretSVG();
        updateFloorIndicator(1); // Set initial floor indicator
        draw();

        // Tactical Map functionality - covers only the toolbar area
        function showTacticalMap() {
            let tacticalOverlay = document.getElementById('tacticalOverlay');
            if (!tacticalOverlay) {
                tacticalOverlay = document.createElement('div');
                tacticalOverlay.id = 'tacticalOverlay';
                tacticalOverlay.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: url("attached_assets/Panel_01_1755741610768.png") center center; background-size: 115% 115%; background-repeat: no-repeat; z-index: 1000; display: none; flex-direction: column; padding: 40px 30px; box-sizing: border-box; overflow: visible;';

                tacticalOverlay.innerHTML = `
                    <div style="display: flex; justify-content: flex-start; align-items: center; margin-bottom: 15px; margin-top: 20px; gap: 10px; margin-left: -20px;">
                        <input type="text" id="newContainerName" placeholder="Container name" maxlength="17" oninput="clearContainerError()" style="width: 160px; padding: 12px; border: 2px solid #8B4513; border-radius: 6px; background: rgba(26, 26, 26, 0.9); color: white; font-weight: bold; backdrop-filter: blur(2px);">
                        <button onclick="addPowerContainer()" style="width: 45px !important; height: 45px !important; min-width: 45px !important; min-height: 45px !important; max-width: 45px !important; max-height: 45px !important; background: url('attached_assets/Plus_1_1755756794789.png') center center; background-size: 40px 40px !important; background-repeat: no-repeat; border: none; border-radius: 6px; cursor: pointer; box-shadow: 0 3px 6px rgba(0,0,0,0.3); margin-left: -10px; display: inline-block; flex-shrink: 0; padding: 0;"></button>
                    </div>
                    <div id="containerList" style="background: transparent; border-radius: 6px; padding: 10px; position: relative; z-index: 2000; margin-top: 20px; overflow: visible;"></div>
                `;

                const toolbar = document.querySelector('.toolbar');
                toolbar.style.position = 'relative';
                toolbar.appendChild(tacticalOverlay);

                // Add turret connection menu to document body
                if (!document.getElementById('turretConnectionMenu')) {
                    const connectionMenu = document.createElement('div');
                    connectionMenu.id = 'turretConnectionMenu';
                    connectionMenu.style.cssText = 'display: none; position: absolute; background: #333; border: 1px solid #555; border-radius: 4px; padding: 4px; z-index: 1000; max-height: 200px; overflow-y: auto;';
                    connectionMenu.innerHTML = `
                        <div style="color: white; font-size: 12px; padding: 4px; border-bottom: 1px solid #555; margin-bottom: 4px;">Connect to Container:</div>
                        <div id="containerMenuList"></div>
                    `;
                    document.body.appendChild(connectionMenu);
                }
            }
            tacticalOverlay.style.display = 'flex';
            document.body.style.backgroundColor = '#2a2a2a';
            document.getElementById('mapCanvas').style.backgroundColor = '#d3d3d3';
            document.querySelector('.canvas-container').style.backgroundColor = '#2a2a2a';
            tacticalModeActive = true;
            draw(); // Redraw with dark grid
            document.getElementById('tacticalMapBtn').classList.add('active');
            document.getElementById('mapEditorBtn').classList.remove('active');
        }

        function showMapEditor() {
            const tacticalOverlay = document.getElementById('tacticalOverlay');
            if (tacticalOverlay) tacticalOverlay.style.display = 'none';
            document.body.style.backgroundColor = '#f4f4f4';
            document.getElementById('mapCanvas').style.backgroundColor = '';
            document.querySelector('.canvas-container').style.backgroundColor = '';
            tacticalModeActive = false;
            draw(); // Redraw with light grid
            document.getElementById('mapEditorBtn').classList.add('active');
            document.getElementById('tacticalMapBtn').classList.remove('active');
        }

        // Power container management system

        function clearContainerError() {
            if (turretManager.containerError) {
                turretManager.containerError = null;
                renderContainerList();
            }
        }

        function addPowerContainer() {
            const nameInput = document.getElementById('newContainerName');
            const containerName = nameInput.value.trim();

            if (turretManager.addPowerContainer(containerName)) {
                nameInput.value = '';
                renderContainerList();
            } else {
                renderContainerList();
                return;
            }

            // Power container addition now handled by turretManager.addPowerContainer() above
        }

        function setContainerState(containerId, enabled) {
            const container = turretManager.powerContainers.find(c => c.id === containerId);
            if (container) {
                container.enabled = enabled;
                renderContainerList();

                // Update the turret counter to reflect powered turrets
                updateFloorIndicator(1);

                // Refresh all canvas displays to update turret power states and FOV
                redrawAllFloorCanvases();
                draw(); // Main canvas
                updateAllFloorDisplays(); // Additional floors
            }
        }

        function addTurretToContainer(containerId, turretNumber) {
            turretManager.connectTurretToContainer(containerId, turretNumber);
            renderContainerList();
            updateFloorIndicator(1); // Update counter
        }

        function removeTurretFromContainer(containerId, turretNumber) {
            turretManager.disconnectTurretFromContainer(containerId, turretNumber);
            renderContainerList();
            updateFloorIndicator(1); // Update counter
        }

        function deleteContainer(containerId) {
            turretManager.deletePowerContainer(containerId);
            renderContainerList();
            updateFloorIndicator(1); // Update counter
        }

        function selectContainer(containerId) {
            turretManager.selectedContainer = turretManager.powerContainers.find(c => c.id === containerId);
            renderContainerList(); // Update selection highlighting
        }

        // Turret connection menu system
        function showTurretConnectionMenu(x, y, turretNumber) {
            const menu = document.getElementById('turretConnectionMenu');
            const menuList = document.getElementById('containerMenuList');

            if (!menu || !menuList) {
                console.warn('Connection menu elements not found');
                return;
            }

            // Hide menu if no containers exist
            if (turretManager.powerContainers.length === 0) {
                hideConnectionMenu();
                return;
            }

            // Populate menu with available containers
            menuList.innerHTML = turretManager.powerContainers.map(container => {
                const isConnected = container.connectedTurrets.includes(turretNumber);
                const action = isConnected ? 'disconnectTurret' : 'connectTurret';
                const text = isConnected ? `Disconnect from ${container.name}` : `Connect to ${container.name}`;
                const bgColor = isConnected ? '#F44336' : '#4CAF50';

                return `
                    <div onclick="${action}(${container.id}, ${turretNumber}); hideConnectionMenu();"
                         style="padding: 6px 8px; margin: 2px 0; background: ${bgColor}; color: white; border-radius: 3px; cursor: pointer; font-size: 11px; text-align: center;">
                        ${text}
                    </div>
                `;
            }).join('');

            // Position and show menu
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.style.display = 'block';
        }

        function hideConnectionMenu() {
            const menu = document.getElementById('turretConnectionMenu');
            if (menu) menu.style.display = 'none';
        }

        function connectTurret(containerId, turretNumber) {
            addTurretToContainer(containerId, turretNumber);
        }

        function disconnectTurret(containerId, turretNumber) {
            removeTurretFromContainer(containerId, turretNumber);
        }

        function removeTurretCompletely(turretNumber) {
            // Find and remove the turret from all floors
            let turretFound = false;

            // Check main floor
            for (let i = turrets.length - 1; i >= 0; i--) {
                if (turrets[i].number === turretNumber) {
                    turrets.splice(i, 1);
                    turretFound = true;
                    break;
                }
            }

            // Check additional floors
            if (!turretFound) {
                for (let floorNum = 2; floorNum <= 5; floorNum++) {
                    const floor = floorManager.floorData[floorNum];
                    if (floor && floor.turrets) {
                        for (let i = floor.turrets.length - 1; i >= 0; i--) {
                            if (floor.turrets[i].number === turretNumber) {
                                floor.turrets.splice(i, 1);
                                turretFound = true;
                                break;
                            }
                        }
                        if (turretFound) break;
                    }
                }
            }

            // Remove from all containers
            turretManager.powerContainers.forEach(container => {
                const index = container.connectedTurrets.indexOf(turretNumber);
                if (index > -1) { // Check if index is valid before splicing
                    container.connectedTurrets.splice(index, 1);
                }
            });

            // Clear selection if this turret was selected
            if (selectedTurret && selectedTurret.number === turretNumber) {
                deselectAll();
                showLineOfSight = false;
                lineOfSightTurret = null;
            }

            // Update displays
            updateSelectedInfo();
            draw();
            updateAllFloorDisplays();
            renderContainerList();
        }

        // Show turret assignment dropdown menu
        function showTurretAssignmentMenu(event, containerId) {
            const unassignedTurrets = getUnassignedTurrets();
            if (unassignedTurrets.length === 0) return;

            // Remove existing assignment menu
            const existingMenu = document.getElementById('turretAssignmentMenu');
            if (existingMenu) existingMenu.remove();

            // Create dropdown menu
            const menu = document.createElement('div');
            menu.id = 'turretAssignmentMenu';
            menu.style.cssText = `
                position: absolute;
                background: #444;
                border: 1px solid #666;
                border-radius: 3px;
                padding: 4px;
                z-index: 10000;
                max-height: 120px;
                overflow-y: auto;
                box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            `;

            menu.innerHTML = unassignedTurrets.map(turretNum => `
                <div onclick="assignTurretToContainer(${containerId}, ${turretNum}); hideAssignmentMenu();"
                     style="padding: 4px 8px; margin: 1px 0; background: #555; color: white; border-radius: 2px; cursor: pointer; font-size: 11px; text-align: center;">
                    Turret ${turretNum}
                </div>
            `).join('');

            // Position and show menu
            menu.style.left = event.pageX + 'px';
            menu.style.top = event.pageY + 'px';
            document.body.appendChild(menu);
        }

        // Show turret removal confirmation menu
        function showTurretRemovalMenu(event, containerId, turretNum) {
            // Remove existing removal menu
            const existingMenu = document.getElementById('turretRemovalMenu');
            if (existingMenu) existingMenu.remove();

            // Create confirmation menu
            const menu = document.createElement('div');
            menu.id = 'turretRemovalMenu';
            menu.style.cssText = `
                position: absolute;
                background: #444;
                border: 1px solid #666;
                border-radius: 3px;
                padding: 4px;
                z-index: 10000;
                box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            `;

            menu.innerHTML = `
                <div style="color: white; font-size: 10px; padding: 2px 4px; text-align: center;">Remove turret?</div>
                <div style="display: flex; gap: 2px; margin-top: 2px;">
                    <button onclick="removeTurretFromContainer(${containerId}, ${turretNum}); hideRemovalMenu();"
                            style="background: #F44336; color: white; border: none; border-radius: 2px; cursor: pointer; font-size: 8px; padding: 2px 6px;">Yes</button>
                    <button onclick="hideRemovalMenu();"
                            style="background: #666; color: white; border: none; border-radius: 2px; cursor: pointer; font-size: 8px; padding: 2px 6px;">Cancel</button>
                </div>
            `;

            // Position and show menu
            menu.style.left = event.pageX + 'px';
            menu.style.top = event.pageY + 'px';
            document.body.appendChild(menu);
        }

        function assignTurretToContainer(containerId, turretNumber) {
            addTurretToContainer(containerId, turretNumber);
        }

        function hideAssignmentMenu() {
            const menu = document.getElementById('turretAssignmentMenu');
            if (menu) menu.remove();
        }

        function hideRemovalMenu() {
            const menu = document.getElementById('turretRemovalMenu');
            if (menu) menu.remove();
        }

        // Hide connection menu when clicking elsewhere
        document.addEventListener('click', function(event) {
            const connectionMenu = document.getElementById('turretConnectionMenu');
            const assignmentMenu = document.getElementById('turretAssignmentMenu');
            const removalMenu = document.getElementById('turretRemovalMenu');

            if (connectionMenu && !connectionMenu.contains(event.target)) {
                hideConnectionMenu();
            }
            if (assignmentMenu && !assignmentMenu.contains(event.target)) {
                hideAssignmentMenu();
            }
            if (removalMenu && !removalMenu.contains(event.target)) {
                hideRemovalMenu();
            }
        });



        // Check if a turret is powered (assigned to an enabled container)
        function isTurretPowered(turretNumber) {
            if (!tacticalModeActive) return false; // Only apply power rules in tactical mode

            // First check if turret is connected to an enabled container
            const isConnected = turretManager.powerContainers.some(container =>
                container.enabled && container.connectedTurrets.includes(turretNumber)
            );

            if (!isConnected) return false;

            // Get all connected turret numbers and sort them (lowest priority)
            const allConnectedTurrets = [];
            turretManager.powerContainers.forEach(container => {
                if (container.enabled) {
                    allConnectedTurrets.push(...container.connectedTurrets);
                }
            });

            // Remove duplicates and sort by turret number (lowest first)
            const uniqueTurrets = [...new Set(allConnectedTurrets)].sort((a, b) => a - b);

            // Check if this turret is within the first 12 (limit)
            const turretIndex = uniqueTurrets.indexOf(turretNumber);
            return turretIndex !== -1 && turretIndex < 12;
        }

        // Check if a turret is over the power limit (connected but not powered due to limit)
        function isTurretOverLimit(turretNumber) {
            if (!tacticalModeActive) return false; // Only apply power rules in tactical mode

            // First check if turret is connected to an enabled container
            const isConnected = turretManager.powerContainers.some(container =>
                container.enabled && container.connectedTurrets.includes(turretNumber)
            );

            if (!isConnected) return false;

            // Get all connected turret numbers and sort them (lowest priority)
            const allConnectedTurrets = [];
            turretManager.powerContainers.forEach(container => {
                if (container.enabled) {
                    allConnectedTurrets.push(...container.connectedTurrets);
                }
            });

            // Remove duplicates and sort by turret number (lowest first)
            const uniqueTurrets = [...new Set(allConnectedTurrets)].sort((a, b) => a - b);

            // Check if this turret is beyond the first 12 (over limit)
            const turretIndex = uniqueTurrets.indexOf(turretNumber);
            return turretIndex !== -1 && turretIndex >= 12;
        }

        function isTurretConnectedButUnpowered(turretNumber) {
            if (!tacticalModeActive) return false; // Only apply in tactical mode

            // Check if turret is connected to any container (enabled or disabled)
            const isConnectedToAnyContainer = turretManager.powerContainers.some(container =>
                container.connectedTurrets.includes(turretNumber)
            );

            if (!isConnectedToAnyContainer) return false;

            // Check if turret is connected to an enabled container
            const isConnectedToEnabledContainer = turretManager.powerContainers.some(container =>
                container.enabled && container.connectedTurrets.includes(turretNumber)
            );

            // Return true if connected to a container but not to an enabled one
            return !isConnectedToEnabledContainer;
        }

        // Get all turrets that should display FOV (powered in tactical mode)
        function getTurretsWithActiveFOV() {
            if (!tacticalModeActive) return []; // No power-based FOV in editor mode

            const activeTurrets = [];
            for (const container of turretManager.powerContainers) {
                if (container.enabled) {
                    activeTurrets.push(...container.connectedTurrets);
                }
            }
            return activeTurrets;
        }

        // Get all unassigned turret numbers
        function getUnassignedTurrets() {
            const allTurrets = [];

            // Collect main floor turrets
            turrets.forEach(turret => {
                if (turret.number) allTurrets.push(turret.number);
            });

            // Collect additional floor turrets
            for (let floorNum = 2; floorNum <= 5; floorNum++) {
                const floor = floorManager.floorData[floorNum];
                if (floor && floor.turrets) {
                    floor.turrets.forEach(turret => {
                        if (turret.number) allTurrets.push(turret.number);
                    });
                }
            }

            // Find assigned turrets
            const assignedTurrets = new Set();
            turretManager.powerContainers.forEach(container => {
                container.connectedTurrets.forEach(turretNum => {
                    assignedTurrets.add(turretNum);
                });
            });

            // Return unassigned turrets
            return allTurrets.filter(turretNum => !assignedTurrets.has(turretNum)).sort((a, b) => a - b);
        }

        function renderContainerList() {
            const containerList = document.getElementById('containerList');
            if (!containerList) {
                console.warn('containerList element not found, skipping render');
                return;
            }

            // Show error message if present, but don't hide existing containers
            let errorHtml = '';
            if (turretManager.containerError) {
                errorHtml = `<div style="color: #ff4444; font-size: 12px; padding: 8px; text-align: center; font-weight: bold; margin-bottom: 10px;">${turretManager.containerError}</div>`;
            }

            if (turretManager.powerContainers.length === 0) {
                containerList.innerHTML = errorHtml;
                return;
            }

            const containersHtml = turretManager.powerContainers.map(container => {
                const isSelected = turretManager.selectedContainer && turretManager.selectedContainer.id === container.id;
                const unassignedTurrets = getUnassignedTurrets();

                // Create turret icons display
                const turretIconsHtml = container.connectedTurrets.map(turretNum => `
                    <div style="position: relative; display: inline-block; margin: 1px;">
                        <svg width="12" height="12" viewBox="0 0 20 20" style="background: transparent; border-radius: 1px;"
                             oncontextmenu="event.preventDefault(); event.stopPropagation(); showTurretRemovalMenu(event, ${container.id}, ${turretNum}); return false;">
                            <circle cx="10" cy="10" r="6" fill="#8B4513" stroke="#654321" stroke-width="1"/>
                            <rect x="8" y="4" width="4" height="8" fill="#A0522D"/>
                            <circle cx="10" cy="10" r="3" fill="#CD853F"/>
                        </svg>
                        <span style="position: absolute; top: -6px; right: -6px; background: #FF6B6B; color: white; border-radius: 50%; width: 10px; height: 10px; font-size: 6px; display: flex; align-items: center; justify-content: center; font-weight: bold;">${turretNum}</span>
                    </div>
                `).join('');

                // Add plus sign if there are unassigned turrets and container has less than 10 turrets
                const plusSignHtml = unassignedTurrets.length > 0 && container.connectedTurrets.length < 10 ? `
                    <div style="position: relative; display: inline-block; margin: 1px;">
                        <div onclick="event.stopPropagation(); showTurretAssignmentMenu(event, ${container.id})"
                             style="width: 12px; height: 12px; background: #555; border: 1px dashed #AAA; border-radius: 1px;
                                    display: flex; align-items: center; justify-content: center; cursor: pointer; color: #AAA; font-size: 10px; font-weight: bold;">+</div>
                    </div>
                ` : '';

                return `
                    <div style="position: relative; height: 80px; margin-bottom: 11px; cursor: pointer;" onclick="selectContainer(${container.id})">
                        <!-- Industrial artwork background -->
                        <img src="attached_assets/NoIcon_1755760480489.png" style="width: 265px; height: 80px; position: absolute; left: -55px; top: 0; z-index: 1;">

                        <!-- ON/OFF switches on the left -->
                        <div style="position: absolute; left: -28px; top: 19px; display: flex; flex-direction: column; gap: 2px; z-index: 2;">
                            <button onclick="event.stopPropagation(); setContainerState(${container.id}, true)"
                                    style="width: 40px; height: 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: bold;
                                           background: ${container.enabled ? '#4CAF50' : '#444'}; color: white;">
                                ON
                            </button>
                            <button onclick="event.stopPropagation(); setContainerState(${container.id}, false)"
                                    style="width: 40px; height: 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: bold;
                                           background: ${!container.enabled ? '#F44336' : '#444'}; color: white;">
                                OFF
                            </button>
                        </div>

                        <!-- Container name in bold red text, above middle, bit to the right -->
                        <div style="position: absolute; left: 71px; top: 14px; color: #ff4444; font-size: 12px; font-weight: bold; z-index: 2;">
                            ${container.name}
                        </div>

                        <!-- Turrets below middle line, left to right -->
                        <div style="position: absolute; left: 35px; top: 44px; display: flex; flex-wrap: wrap; gap: 2px; width: 180px; z-index: 2;">
                            ${turretIconsHtml}${plusSignHtml}
                        </div>
                    </div>
                `;
            }).join('');

            containerList.innerHTML = errorHtml + containersHtml;
        }

        // Power distribution display removed - no longer needed

        // Save and Load System
        function saveMapState(mapName) {
            if (!mapName) {
                alert('Please enter a map name');
                return;
            }



            const mapData = {
                name: mapName,
                timestamp: new Date().toISOString(),
                // Main floor data
                mainFloor: {
                    shapes: shapes.map(shape => ({
                        type: shape.constructor.name,
                        centerX: shape.x || shape.centerX || 0,
                        centerY: shape.y || shape.centerY || 0,
                        rotation: shape.rotation || 0,
                        transparent: shape.transparent !== undefined ? shape.transparent : true,
                        data: shape.serialize ? shape.serialize() : {}
                    })),
                    edgeItems: [
                        ...walls.map(item => ({
                            type: 'Wall',
                            startX: item.edge ? item.edge.start.x : 0,
                            startY: item.edge ? item.edge.start.y : 0,
                            endX: item.edge ? item.edge.end.x : 0,
                            endY: item.edge ? item.edge.end.y : 0
                        })),
                        ...windows.map(item => ({
                            type: 'Window',
                            startX: item.edge ? item.edge.start.x : 0,
                            startY: item.edge ? item.edge.start.y : 0,
                            endX: item.edge ? item.edge.end.x : 0,
                            endY: item.edge ? item.edge.end.y : 0
                        })),
                        ...reinforcedWalls.map(item => ({
                            type: 'ReinforcedWall',
                            startX: item.edge ? item.edge.start.x : 0,
                            startY: item.edge ? item.edge.start.y : 0,
                            endX: item.edge ? item.edge.end.x : 0,
                            endY: item.edge ? item.edge.end.y : 0
                        })),
                        ...garageDoors.map(item => ({
                            type: 'GarageDoor',
                            startX: item.edge ? item.edge.start.x : 0,
                            startY: item.edge ? item.edge.start.y : 0,
                            endX: item.edge ? item.edge.end.x : 0,
                            endY: item.edge ? item.edge.end.y : 0,
                            isOpen: item.isOpen
                        })),
                        ...securityGates.map(item => ({
                            type: 'SecurityGate',
                            startX: item.edge ? item.edge.start.x : 0,
                            startY: item.edge ? item.edge.start.y : 0,
                            endX: item.edge ? item.edge.end.x : 0,
                            endY: item.edge ? item.edge.end.y : 0
                        }))
                    ],
                    turrets: turrets.map(turret => ({
                        x: turret.x,
                        y: turret.y,
                        rotation: turret.rotation,
                        number: turret.number
                    }))
                },
                // Additional floors data
                additionalFloors: Object.keys(floorManager.floorData).reduce((acc, floorNum) => {
                    if (floorNum !== '1') {
                        const floor = floorManager.floorData[floorNum];
                        acc[floorNum] = {
                            shapes: floor.shapes ? floor.shapes.map(shape => ({
                                type: shape.constructor.name,
                                centerX: shape.centerX || shape.x || 0,
                                centerY: shape.centerY || shape.y || 0,
                                rotation: shape.rotation || 0,
                                transparent: true,
                                data: shape.serialize ? shape.serialize() : {}
                            })) : [],
                            edgeItems: [
                                ...(floor.walls || []).map(item => ({
                                    type: 'Wall',
                                    startX: item.edge ? item.edge.start.x : 0,
                                    startY: item.edge ? item.edge.start.y : 0,
                                    endX: item.edge ? item.edge.end.x : 0,
                                    endY: item.edge ? item.edge.end.y : 0
                                })),
                                ...(floor.windows || []).map(item => ({
                                    type: 'Window',
                                    startX: item.edge ? item.edge.start.x : 0,
                                    startY: item.edge ? item.edge.start.y : 0,
                                    endX: item.edge ? item.edge.end.x : 0,
                                    endY: item.edge ? item.edge.end.y : 0
                                })),
                                ...(floor.reinforcedWalls || []).map(item => ({
                                    type: 'ReinforcedWall',
                                    startX: item.edge ? item.edge.start.x : 0,
                                    startY: item.edge ? item.edge.start.y : 0,
                                    endX: item.edge ? item.edge.end.x : 0,
                                    endY: item.edge ? item.edge.end.y : 0
                                })),
                                ...(floor.garageDoors || []).map(item => ({
                                    type: 'GarageDoor',
                                    startX: item.edge ? item.edge.start.x : 0,
                                    startY: item.edge ? item.edge.start.y : 0,
                                    endX: item.edge ? item.edge.end.x : 0,
                                    endY: item.edge ? item.edge.end.y : 0,
                                    isOpen: item.isOpen
                                })),
                                ...(floor.securityGates || []).map(item => ({
                                    type: 'SecurityGate',
                                    startX: item.edge ? item.edge.start.x : 0,
                                    startY: item.edge ? item.edge.start.y : 0,
                                    endX: item.edge ? item.edge.end.x : 0,
                                    endY: item.edge ? item.edge.end.y : 0
                                }))
                            ],
                            turrets: floor.turrets ? floor.turrets.map(turret => ({
                                x: turret.x || 0,
                                y: turret.y || 0,
                                rotation: turret.rotation || 0,
                                number: turret.number || 0
                            })) : []
                        };
                    }
                    return acc;
                }, {}),
                // Power management system
                powerContainers: turretManager.powerContainers.map(container => ({
                    id: container.id,
                    name: container.name,
                    enabled: container.enabled,
                    connectedTurrets: [...container.connectedTurrets]
                })),
                // Settings
                settings: {
                    currentFloorLayout: parseInt(document.getElementById('floorSelect').value),
                    tacticalMode: tacticalModeActive,
                    currentActiveFloor: floorManager.currentActiveFloor
                }
            };

            // Save to localStorage with shapemap_ prefix
            localStorage.setItem(`shapemap_${mapName}`, JSON.stringify(mapData));

            alert(`Map "${mapName}" saved successfully!`);
        }

        // Convert old map format to new format for compatibility
        function convertOldFormatToNew(oldData) {
            // Helper function to safely convert edge items
            function convertEdgeItems(items, type) {
                if (!items || !Array.isArray(items)) return [];
                return items.filter(item => item && item.edge && item.edge.start && item.edge.end)
                           .map(item => ({
                               type: type,
                               startX: item.edge.start.x,
                               startY: item.edge.start.y,
                               endX: item.edge.end.x,
                               endY: item.edge.end.y,
                               ...(item.isOpen !== undefined && { isOpen: item.isOpen })
                           }));
            }

            const newData = {
                name: oldData.name || 'Converted Map',
                timestamp: oldData.timestamp || new Date().toISOString(),
                mainFloor: {
                    shapes: (oldData.shapes || []).map(shape => ({
                        type: shape.type,
                        centerX: shape.centerX || shape.x || 0,
                        centerY: shape.centerY || shape.y || 0,
                        rotation: shape.rotation || 0,
                        transparent: shape.transparent !== undefined ? shape.transparent : true,
                        data: shape.data || {}
                    })),
                    edgeItems: [
                        ...convertEdgeItems(oldData.walls, 'Wall'),
                        ...convertEdgeItems(oldData.windows, 'Window'),
                        ...convertEdgeItems(oldData.reinforcedWalls, 'ReinforcedWall'),
                        ...convertEdgeItems(oldData.garageDoors, 'GarageDoor'),
                        ...convertEdgeItems(oldData.securityGates, 'SecurityGate')
                    ],
                    turrets: (oldData.turrets || []).map(turret => ({
                        x: turret.x || 0,
                        y: turret.y || 0,
                        rotation: turret.rotation || 0,
                        number: turret.number || 1
                    }))
                },
                additionalFloors: oldData.floorData || {},
                powerContainers: oldData.powerContainers || [],
                settings: oldData.settings || {}
            };
            return newData;
        }

        function loadMapState(mapData) {
            if (!mapData) {
                alert('No map data provided');
                return;
            }

            if (!confirm(`Load map "${mapData.name}"? This will replace your current map.`)) {
                return;
            }

            // Convert old format to new format if needed
            if (!mapData.mainFloor && (mapData.shapes || mapData.walls || mapData.turrets)) {
                mapData = convertOldFormatToNew(mapData);
            }

            try {
                loadMapData(mapData);
            } catch (error) {
                alert('Error loading map data');
                console.error('Load error:', error);
            }
        }

        function loadMapData(mapData) {
            console.log('Loading map data:', mapData);

            // Clear current state
            shapes.length = 0;
            turrets.length = 0;
            turretManager.powerContainers.length = 0;

            // Clear floor data
            Object.keys(floorManager.floorData).forEach(key => {
                if (key !== '1') {
                    floorManager.floorData[key] = {
                        shapes: [],
                        turrets: [],
                        walls: [],
                        windows: [],
                        reinforcedWalls: [],
                        garageDoors: [],
                        securityGates: []
                    };
                }
            });

            // Load main floor data
            const mainFloor = mapData.mainFloor;

            if (!mainFloor) {
                throw new Error('Invalid map data: missing mainFloor');
            }

            // Restore shapes
            if (mainFloor.shapes) {
                mainFloor.shapes.forEach(shapeData => {
                let shape;
                if (shapeData.type === 'Square') {
                    shape = new Square(shapeData.centerX, shapeData.centerY);
                } else if (shapeData.type === 'Triangle') {
                    shape = new Triangle(shapeData.centerX, shapeData.centerY);
                }
                if (shape) {
                    shape.rotation = shapeData.rotation;
                    shape.selected = false;
                    shape.transparent = true; // Always transparent
                    if (shape.deserialize && shapeData.data) {
                        shape.deserialize(shapeData.data);
                    }
                    shapes.push(shape);
                }
                });
            }

            // Clear edge arrays
            walls.length = 0;
            windows.length = 0;
            reinforcedWalls.length = 0;
            garageDoors.length = 0;
            securityGates.length = 0;

            // Restore edge items
            if (mainFloor.edgeItems) {
                mainFloor.edgeItems.forEach(itemData => {
                // Skip items without edge data
                if (itemData.startX === undefined || itemData.startY === undefined ||
                    itemData.endX === undefined || itemData.endY === undefined) {
                    console.warn('Skipping edge item with missing edge data:', itemData);
                    return;
                }

                const edge = {
                    start: { x: itemData.startX, y: itemData.startY },
                    end: { x: itemData.endX, y: itemData.endY }
                };

                let item;
                if (itemData.type === 'Wall') {
                    item = new Wall(edge);
                    walls.push(item);
                } else if (itemData.type === 'Window') {
                    item = new Window(edge);
                    windows.push(item);
                } else if (itemData.type === 'ReinforcedWall') {
                    item = new ReinforcedWall(edge);
                    reinforcedWalls.push(item);
                } else if (itemData.type === 'GarageDoor') {
                    item = new GarageDoor(edge);
                    if (itemData.isOpen !== undefined) item.isOpen = itemData.isOpen;
                    garageDoors.push(item);
                } else if (itemData.type === 'SecurityGate') {
                    item = new SecurityGate(edge);
                    securityGates.push(item);
                }
                });
            }

            // Restore turrets
            if (mainFloor.turrets) {
                mainFloor.turrets.forEach(turretData => {
                const turret = new Turret(turretData.x, turretData.y);
                turret.rotation = turretData.rotation;
                turret.number = turretData.number;
                turrets.push(turret);
                });
            }

            // Load additional floors
            if (mapData.additionalFloors) {
                Object.keys(mapData.additionalFloors).forEach(floorNum => {
                const floorData_backup = mapData.additionalFloors[floorNum];
                const floor = floorManager.floorData[floorNum] = { shapes: [], edgeItems: [], turrets: [] };

                // Restore shapes for this floor
                floorData_backup.shapes.forEach(shapeData => {
                    let shape;
                    if (shapeData.type === 'Square') {
                        shape = new Square(shapeData.centerX, shapeData.centerY);
                    } else if (shapeData.type === 'Triangle') {
                        shape = new Triangle(shapeData.centerX, shapeData.centerY);
                    } else if (shapeData.type === 'Square2') {
                        shape = new Square2(shapeData.centerX, shapeData.centerY);
                    }
                    if (shape) {
                        shape.rotation = shapeData.rotation;
                        shape.isOpaque = shapeData.isOpaque;
                        floor.shapes.push(shape);
                    }
                });

                // Initialize edge arrays for this floor
                floor.walls = floor.walls || [];
                floor.windows = floor.windows || [];
                floor.reinforcedWalls = floor.reinforcedWalls || [];
                floor.garageDoors = floor.garageDoors || [];
                floor.securityGates = floor.securityGates || [];

                // Restore edge items for this floor
                floorData_backup.edgeItems.forEach(itemData => {
                    // Skip items without edge data
                    if (itemData.startX === undefined || itemData.startY === undefined ||
                        itemData.endX === undefined || itemData.endY === undefined) {
                        console.warn('Skipping floor edge item with missing edge data:', itemData);
                        return;
                    }

                    const edge = {
                        start: { x: itemData.startX, y: itemData.startY },
                        end: { x: itemData.endX, y: itemData.endY }
                    };

                    let item;
                    if (itemData.type === 'Wall') {
                        item = new Wall(edge);
                        floor.walls.push(item);
                    } else if (itemData.type === 'Window') {
                        item = new Window(edge);
                        floor.windows.push(item);
                    } else if (itemData.type === 'ReinforcedWall') {
                        item = new ReinforcedWall(edge);
                        floor.reinforcedWalls.push(item);
                    } else if (itemData.type === 'GarageDoor') {
                        item = new GarageDoor(edge);
                        if (itemData.isOpen !== undefined) item.isOpen = itemData.isOpen;
                        floor.garageDoors.push(item);
                    } else if (itemData.type === 'SecurityGate') {
                        item = new SecurityGate(edge);
                        floor.securityGates.push(item);
                    }
                });

                // Restore turrets for this floor
                floorData_backup.turrets.forEach(turretData => {
                    const turret = new Turret(turretData.x, turretData.y);
                    turret.rotation = turretData.rotation;
                    turret.number = turretData.number;
                    turret.floorNumber = parseInt(floorNum);
                    floor.turrets.push(turret);
                });
                });
            }

            // Restore power containers
            turretManager.powerContainers.length = 0;
            if (mapData.powerContainers) {
                mapData.powerContainers.forEach(containerData => {
                turretManager.powerContainers.push({
                    id: containerData.id,
                    name: containerData.name,
                    enabled: containerData.enabled,
                    connectedTurrets: [...containerData.connectedTurrets]
                });
                });
            }

            // Restore settings
            if (mapData.settings) {
                document.getElementById('floorSelect').value = mapData.settings.currentFloorLayout;
                floorManager.currentActiveFloor = mapData.settings.currentActiveFloor || 1;

                // Switch to appropriate mode
                if (mapData.settings.tacticalMode) {
                    showTacticalMap();
                } else {
                    showMapEditor();
                }

                // Update floor layout (if function exists)
                if (typeof updateFloorDisplay === 'function') {
                    updateFloorDisplay(mapData.settings.currentFloorLayout);
                }
                // if (typeof switchToFloor === 'function') {
                //     switchToFloor(floorManager.currentActiveFloor);
                // }
            }

            // Update displays (check if functions exist)
            if (typeof updateSelectedInfo === 'function') updateSelectedInfo();
            if (typeof updateFloorIndicator === 'function') updateFloorIndicator(floorManager.currentActiveFloor);
            if (typeof renderContainerList === 'function') renderContainerList();
            if (typeof draw === 'function') draw();
            if (typeof updateAllFloorDisplays === 'function') updateAllFloorDisplays();

            alert(`Map "${mapData.name}" loaded successfully!`);
        }

        function showLoadMapList() {
            const savedMaps = JSON.parse(localStorage.getItem('savedMaps') || '{}');
            const mapNames = Object.keys(savedMaps);

            if (mapNames.length === 0) {
                alert('No saved maps found!');
                return;
            }

            let mapList = 'Available maps:\n';
            mapNames.forEach((name, index) => {
                const mapData = savedMaps[name];
                const date = new Date(mapData.timestamp).toLocaleString();
                mapList += `${index + 1}. ${name} (saved: ${date})\n`;
            });

            const choice = prompt(mapList + '\nEnter map name to load:');
            if (choice && savedMaps[choice]) {
                loadMapState(savedMaps[choice]);
            }
        }

        // Enhanced Modal System Functions
        function openMapModal() {
            const modal = document.getElementById('mapModal');
            if (modal) {
                modal.style.display = 'flex';
                modal.style.alignItems = 'center';
                modal.style.justifyContent = 'center';
            }
        }

        function closeMapModal() {
            const modal = document.getElementById('mapModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        function showSaveModal() {
            const modal = document.getElementById('mapModal');
            if (!modal) {
                // Fallback to simple prompt if modal doesn't exist
                const mapName = prompt('Enter map name:');
                if (mapName) {
                    saveMapState(mapName);
                }
                return;
            }
            openMapModal();
            document.getElementById('modalTitle').textContent = '💾 Save Map';
            document.getElementById('modalContent').innerHTML = `
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #2c3e50;">Map Name:</label>
                    <input type="text" id="saveMapNameInput" placeholder="Enter map name..."
                           style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; box-sizing: border-box;">
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="closeMapModal()"
                            style="padding: 10px 20px; background: #95a5a6; color: white; border: none; border-radius: 6px; cursor: pointer;">
                        Cancel
                    </button>
                    <button onclick="performSave()"
                            style="padding: 10px 20px; background: #27ae60; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">
                        Save Map
                    </button>
                </div>
            `;
            setTimeout(() => document.getElementById('saveMapNameInput').focus(), 100);
        }

        function showLoadModal() {
            const modal = document.getElementById('mapModal');
            if (!modal) {
                // Fallback to simple prompt if modal doesn't exist
                showLoadMapList();
                return;
            }
            openMapModal();
            document.getElementById('modalTitle').textContent = '📁 Load Map';

            const savedMaps = Object.keys(localStorage).filter(key => key.startsWith('shapemap_')).map(key => {
                try {
                    const mapData = JSON.parse(localStorage.getItem(key));
                    return { key, ...mapData };
                } catch (e) {
                    console.error('Error parsing map data for key:', key);
                    return null;
                }
            }).filter(map => map !== null);

            let content = '<div style="margin-bottom: 20px;">';
            if (savedMaps.length === 0) {
                content += '<p style="text-align: center; color: #7f8c8d; font-style: italic;">No saved maps found</p>';
            } else {
                content += '<div style="max-height: 400px; overflow-y: auto;">';
                savedMaps.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)).forEach(map => {
                    const date = new Date(map.timestamp).toLocaleDateString();
                    const time = new Date(map.timestamp).toLocaleTimeString();
                    content += `
                        <div style="border: 1px solid #ddd; border-radius: 6px; padding: 15px; margin-bottom: 10px; background: #f8f9fa; cursor: pointer; transition: background 0.2s;"
                             onclick="loadMapFromStorage('${map.key}')"
                             onmouseover="this.style.background='#e9ecef'"
                             onmouseout="this.style.background='#f8f9fa'">
                            <div style="font-weight: bold; color: #2c3e50; margin-bottom: 5px;">${map.name}</div>
                            <div style="font-size: 12px; color: #7f8c8d;">Saved: ${date} at ${time}</div>
                        </div>
                    `;
                });
                content += '</div>';
            }
            content += '</div>';
            content += `
                <div style="display: flex; justify-content: flex-end;">
                    <button onclick="closeMapModal()"
                            style="padding: 10px 20px; background: #95a5a6; color: white; border: none; border-radius: 6px; cursor: pointer;">
                        Close
                    </button>
                </div>
            `;
            document.getElementById('modalContent').innerHTML = content;
        }

        function showManageModal() {
            const modal = document.getElementById('mapModal');
            if (!modal) {
                alert('Map management requires the modal system. Please refresh the page.');
                return;
            }
            openMapModal();
            document.getElementById('modalTitle').textContent = '⚙️ Manage Maps';

            const savedMaps = Object.keys(localStorage).filter(key => key.startsWith('shapemap_')).map(key => {
                try {
                    const mapData = JSON.parse(localStorage.getItem(key));
                    return { key, ...mapData };
                } catch (e) {
                    console.error('Error parsing map data for key:', key);
                    return null;
                }
            }).filter(map => map !== null);

            let content = '<div style="margin-bottom: 20px;">';
            if (savedMaps.length === 0) {
                content += '<p style="text-align: center; color: #7f8c8d; font-style: italic;">No saved maps found</p>';
            } else {
                content += '<div style="max-height: 400px; overflow-y: auto;">';
                savedMaps.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)).forEach(map => {
                    const date = new Date(map.timestamp).toLocaleDateString();
                    const time = new Date(map.timestamp).toLocaleTimeString();
                    content += `
                        <div style="border: 1px solid #ddd; border-radius: 6px; padding: 15px; margin-bottom: 10px; background: #f8f9fa; display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-weight: bold; color: #2c3e50; margin-bottom: 5px;">${map.name}</div>
                                <div style="font-size: 12px; color: #7f8c8d;">Saved: ${date} at ${time}</div>
                            </div>
                            <button onclick="deleteMap('${map.key}', '${map.name}')"
                                    style="padding: 8px 12px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                Delete
                            </button>
                        </div>
                    `;
                });
                content += '</div>';
            }
            content += '</div>';
            content += `
                <div style="display: flex; justify-content: space-between;">
                    <button onclick="clearAllMaps()"
                            style="padding: 10px 20px; background: #e74c3c; color: white; border: none; border-radius: 6px; cursor: pointer;">
                        Clear All
                    </button>
                    <button onclick="closeMapModal()"
                            style="padding: 10px 20px; background: #95a5a6; color: white; border: none; border-radius: 6px; cursor: pointer;">
                        Close
                    </button>
                </div>
            `;
            document.getElementById('modalContent').innerHTML = content;
        }

        function performSave() {
            const mapName = document.getElementById('saveMapNameInput').value.trim();
            if (!mapName) {
                alert('Please enter a map name');
                return;
            }
            saveMapState(mapName);
            closeMapModal();
        }

        function loadMapFromStorage(key) {
            try {
                const mapData = JSON.parse(localStorage.getItem(key));
                if (mapData) {
                    loadMapState(mapData);
                    closeMapModal();
                } else {
                    alert('Error: Map data not found');
                }
            } catch (error) {
                console.error('Error loading map:', error);
                alert('Error loading map data');
            }
        }

        function deleteMap(key, name) {
            if (confirm(`Are you sure you want to delete "${name}"?`)) {
                localStorage.removeItem(key);
                showManageModal(); // Refresh the modal
            }
        }

        function clearAllMaps() {
            if (confirm('Are you sure you want to delete ALL saved maps? This cannot be undone.')) {
                Object.keys(localStorage).filter(key => key.startsWith('shapemap_')).forEach(key => {
                    localStorage.removeItem(key);
                });
                showManageModal(); // Refresh the modal
            }
        }

        // Handle click events on additional floor canvases for selection
        function handleFloorCanvasClick(e, canvasId, floorNum) {
            const canvas = elements[canvasId];
            const rect = canvas.getBoundingClientRect();
            const state = floorManager.floorCanvasStates[canvasId];

            // Convert screen coordinates to world coordinates
            const x = (e.clientX - rect.left - state.panX) / state.zoom;
            const y = (e.clientY - rect.top - state.panY) / state.zoom;



            const floor = floorManager.floorData[floorNum];
            if (!floor) return;

            // Don't clear global selections when selecting on additional floors
            // This allows independent selections across all floors

            // Check if clicking on any turret first
            const clickedTurret = floor.turrets.find(turret => {
                const distance = Math.sqrt((x - turret.x) ** 2 + (y - turret.y) ** 2);
                console.log(`Checking turret ${turret.number || 'unnumbered'} at ${turret.x}, ${turret.y}, distance: ${distance}`);
                return distance <= 25; // 25px click radius for turrets
            });

            if (clickedTurret) {
                // Handle turret selection (existing logic)
                return;
            }

            // Select a shape
            let clickedShape = floor.shapes.find(shape => {
                if (shape.contains && shape.contains(x, y)) {
                    return true;
                }
                return false;
            });

            if (clickedShape) {
                // Select the shape
                clickedShape.selected = true;
                selectedShape = clickedShape;
                floorManager.selectedFloor = floorNum;



                // Redraw only this floor to show selection
                redrawFloorCanvasContent(canvasId, floorNum);
                return;
            }

            // Select an edge item (wall, window, etc.)
            const allEdgeItems = [
                ...floor.walls,
                ...floor.windows,
                ...(floor.reinforcedWalls || []),
                ...(floor.garageDoors || []),
                ...(floor.securityGates || [])
            ];

            const clickedEdgeItem = allEdgeItems.find(item => {
                if (!item.edge) return false;
                const distance = distancePointToLine(x, y, item.edge);
                return distance <= 10; // 10px tolerance for edge items
            });

            if (clickedEdgeItem) {
                // Select the edge item
                clickedEdgeItem.selected = true;
                floorManager.selectedFloor = floorNum;

                // Set appropriate selected variable based on type
                if (floor.walls.includes(clickedEdgeItem)) selectedWall = clickedEdgeItem;
                else if (floor.windows.includes(clickedEdgeItem)) selectedWindow = clickedEdgeItem;
                else if (floor.reinforcedWalls && floor.reinforcedWalls.includes(clickedEdgeItem)) selectedReinforcedWall = clickedEdgeItem;
                else if (floor.garageDoors && floor.garageDoors.includes(clickedEdgeItem)) selectedGarageDoor = clickedEdgeItem;
                else if (floor.securityGates && floor.securityGates.includes(clickedEdgeItem)) selectedSecurityGate = clickedEdgeItem;



                // Redraw only this floor to show selection
                redrawFloorCanvasContent(canvasId, floorNum);
                return;
            }

            // If no items selected, clear selections only on this floor
            clearFloorSelections(floor);
            // Also clear global selections if the previously selected item was on this floor
            clearGlobalSelectionsFromFloor(floor);

            // Redraw only this floor canvas
            redrawFloorCanvasContent(canvasId, floorNumber);
            draw(); // Also redraw main canvas in case it needs updating
            updateSelectedInfo();
        }

        setTimeout(() => {
            elements.tacticalMapBtn.addEventListener('click', showTacticalMap);
            elements.mapEditorBtn.addEventListener('click', showMapEditor);
            elements.saveMapBtn.addEventListener('click', showSaveModal);
            elements.loadMapBtn.addEventListener('click', showLoadModal);
            elements.manageMapBtn.addEventListener('click', showManageModal);

            // Add click event listeners for additional floor canvases
            const floorCanvases = [
                { id: 'floor2Canvas', floorNum: 2 },
                { id: 'floor3Canvas', floorNum: 3 },
                { id: 'floor4Canvas', floorNum: 4 },
                { id: 'floor5Canvas', floorNum: 5 }
            ];

            floorCanvases.forEach(({ id, floorNum }) => {
                const canvas = elements[id];
                if (canvas) {
                    // Add click handler - rely on global keyboard events like main canvas
                    canvas.addEventListener('click', (e) => {
                        handleFloorCanvasClick(e, id, floorNum);
                        // Force focus back to document body for consistent global keyboard handling
                        document.body.focus();
                    });

                    // Don't add individual keyboard listeners - use global ones like main canvas
                    // This ensures consistent behavior between main canvas and additional floors
                }
            });

            // Patch: Override selectTool to update floor canvas cursors
            const originalSelectTool = window.selectTool;
            if (originalSelectTool) {
                window.selectTool = function(toolName) {
                    originalSelectTool(toolName);
                    // Update cursor for additional floor canvases
                    setTimeout(() => {
                        const floor2Canvas = document.getElementById('floor2Canvas');
                        const floor3Canvas = document.getElementById('floor3Canvas');
                        const floor4Canvas = document.getElementById('floor4Canvas');
                        const floor5Canvas = document.getElementById('floor5Canvas');
                        if (floor2Canvas) floor2Canvas.style.cursor = 'crosshair';
                        if (floor3Canvas) floor3Canvas.style.cursor = 'crosshair';
                        if (floor4Canvas) floor4Canvas.style.cursor = 'crosshair';
                        if (floor5Canvas) floor5Canvas.style.cursor = 'crosshair';
                    }, 50);
                };
            }
        }, 100);


    </script>

    <!-- Save/Load Modal System -->
    <div id="mapModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; border-radius: 8px; padding: 20px; max-width: 500px; width: 90%; max-height: 80%; overflow-y: auto; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #ecf0f1; padding-bottom: 10px;">
                <h2 id="modalTitle" style="margin: 0; color: #2c3e50;">Map Library</h2>
                <button onclick="closeMapModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #7f8c8d;">×</button>
            </div>
            <div id="modalContent"></div>
        </div>
    </div>
</body>
</html>